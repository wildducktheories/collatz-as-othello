<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Othello Board Collatz Cycle Explorer</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f5f5f5;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 8px 8px 0 0;
    }

    h1 {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    header p {
      font-size: 14px;
      opacity: 0.95;
    }

    .panel {
      padding: 25px;
      border-bottom: 1px solid #e0e0e0;
    }

    .panel:last-child {
      border-bottom: none;
      border-radius: 0 0 8px 8px;
    }

    .panel h2 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      color: #333;
    }

    .panel h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 10px;
      color: #555;
    }

    .config-panel {
      background: #fafafa;
    }

    .input-group {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }

    .input-field {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .input-field label {
      font-size: 13px;
      font-weight: 500;
      color: #555;
    }

    .input-field input {
      width: 100px;
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .input-field input:focus {
      outline: none;
      border-color: #667eea;
    }

    .output-field {
      width: 100px;
      padding: 8px 10px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background: #f5f5f5;
      font-size: 14px;
      color: #333;
      font-family: 'Courier New', Courier, monospace;
    }

    .output-field-binary {
      min-width: 200px;
      max-width: 400px;
      padding: 8px 10px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background: #f5f5f5;
      font-size: 12px;
      color: #333;
      font-family: 'Courier New', Courier, monospace;
      word-break: break-all;
      overflow-wrap: break-word;
    }

    button {
      padding: 10px 18px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: #667eea;
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: #5568d3;
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: #e0e0e0;
      color: #333;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #d0d0d0;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    .btn-danger:hover:not(:disabled) {
      background: #dc2626;
    }

    .canvas-container {
      display: flex;
      justify-content: center;
      padding: 30px;
      overflow: auto;
      background: #fafafa;
      min-height: 400px;
    }

    #board-canvas {
      border: 2px solid #ddd;
      border-radius: 4px;
      background: white;
      cursor: pointer;
    }

    .polynomial-display {
      font-family: 'Courier New', Courier, monospace;
      font-size: 16px;
      padding: 15px;
      background: #f9f9f9;
      border-radius: 4px;
      overflow-x: auto;
      border: 1px solid #e0e0e0;
      min-height: 50px;
    }

    .control-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .conservation-laws {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
    }

    .law-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .selected-info {
      padding: 12px;
      background: #fff9db;
      border-radius: 4px;
      margin-bottom: 15px;
      border-left: 4px solid #fbbf24;
      font-size: 14px;
    }

    .validation-error {
      color: #dc2626;
      margin-top: 10px;
      padding: 10px;
      background: #fee;
      border-radius: 4px;
      font-size: 13px;
    }

    .success-message {
      color: #059669;
      margin-top: 10px;
      padding: 10px;
      background: #d1fae5;
      border-radius: 4px;
      font-size: 13px;
    }

    .status-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      margin-top: 10px;
    }

    .status-active {
      background: #dbeafe;
      color: #1e40af;
    }

    .status-zero {
      background: #d1fae5;
      color: #065f46;
    }

    label {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    input[type="checkbox"] {
      cursor: pointer;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 25px;
      border-radius: 8px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }

    .modal-content h3 {
      margin-bottom: 15px;
      color: #333;
    }

    .modal-content input {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      margin: 10px 0;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      justify-content: flex-end;
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .input-group {
        flex-direction: column;
      }

      .input-field input {
        width: 100%;
      }

      .control-grid {
        grid-template-columns: 1fr;
      }

      header {
        padding: 20px;
      }

      h1 {
        font-size: 22px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Othello Board Collatz Cycle Explorer</h1>
      <p>Interactive visualization of Collatz-type cycles using the Othello board analogy.
      See <a href="https://drive.google.com/file/d/1jdISz5k3N2xCxASek1AGC6UGJeYRF0V1/view" target="_blank" style="color: #ffffff; text-decoration: underline;">this paper</a> for background.
      For questions or comments, see <a href="https://www.reddit.com/r/Collatz/comments/1pj1hjv/announcing_the_interactive_collatz_othello_board/" target="_blank" style="color: #ffffff; text-decoration: underline;">this Reddit thread</a>.</p>
    </header>

    <div class="config-panel panel">
      <h2>Configuration</h2>
      <div class="input-group">
        <div class="input-field">
          <label>p (path):</label>
          <input type="text" id="input-p" value="1093">
        </div>
        <div class="input-field">
          <label>g (multiplier):</label>
          <input type="number" id="input-g" value="3" min="2">
        </div>
        <div class="input-field">
          <label>h (divisor):</label>
          <input type="number" id="input-h" value="2" min="2">
        </div>
      </div>

      <h3 style="font-size: 14px; font-weight: 600; margin: 15px 0 8px 0; color: #555;">Identifier</h3>
      <div class="input-group">
        <div class="input-field">
          <label>p:</label>
          <a href="#" id="output-p" style="color: #0066cc; cursor: pointer;">1093</a>
        </div>
        <div class="input-field">
          <label>b:</label>
          <a href="#" id="output-b" style="color: #0066cc; cursor: pointer;">0b10001000101</a>
        </div>
        <div class="input-field">
          <label>oe:</label>
          <a href="#" id="output-oe" style="color: #0066cc; cursor: pointer;">OEEOEEEO</a>
        </div>
      </div>

      <div class="input-group">
        <div class="input-field">
          <label>o (multipler steps):</label>
          <span id="output-o">3</span>
        </div>
        <div class="input-field">
          <label>e (divisor steps):</label>
          <span id="output-e">7</span>
        </div>
        <div class="input-field">
          <label>q (quotient):</label>
          <span id="output-q">1</span>
        </div>
        <div class="input-field">
          <label>x‚ÇÄ (cycle start):</label>
          <span id="output-x0">17</span>
        </div>
      </div>
      <div class="input-group">
        <button class="btn-primary" id="init-btn">Initialize Board</button>
      </div>
      <div style="margin-top: 15px;">
        <h3 style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #555;">Examples:</h3>
        <div style="font-size: 13px; line-height: 1.8; color: #666;">
          <strong>g=3, h=2:</strong>
          <a href="?p=9&g=3&h=2">p=9</a>,
          <a href="?p=37&g=3&h=2">p=37</a>,
          <a href="?p=73&g=3&h=2">p=73</a>,
          <a href="?p=585&g=3&h=2">p=585</a>,
          <a href="?p=281&g=3&h=2">p=281</a>,
          <a href="?p=293&g=3&h=2">p=293</a>,
          <a href="?p=2119&g=3&h=2">p=2119</a>,
          <a href="?p=4681&g=3&h=2">p=4681</a>,
          <a href="?p=8301&g=3&h=2">p=8301</a>
          <br>
          <strong>g=5, h=2:</strong>
          <a href="?p=133&g=5&h=2">p=133</a>,
          <a href="?p=1045&g=5&h=2">p=1045</a>,
          <a href="?p=1093&g=5&h=2">p=1093</a>
          <br>
          <strong>g=181, h=2:</strong>
          <a href="?p=131089&g=181&h=2">p=131089</a>,
          <a href="?p=131201&g=181&h=2">p=131201</a>
          <br>
          <strong>g=8, h=3:</strong>
          <a href="?p=585&g=8&h=3">p=585</a>
        </div>
      </div>
      <div id="validation-message"></div>
    </div>

    <div class="control-panel panel">
      <h2>Controls</h2>
      <div class="selected-info" id="selected-info">
        No cell selected. Click a cell on the board to select it.
      </div>
      <div class="control-grid">
        <button class="btn-secondary" id="undo-btn" disabled>‚ü≤ Undo</button>
        <button class="btn-secondary" id="redo-btn" disabled>‚ü≥ Redo</button>
        <button class="btn-secondary" id="reset-btn" disabled>Reset</button>
        <label><input type="checkbox" id="spread-mode"> Spread</label>
      </div>
      <div style="margin-top: 10px; font-size: 12px; color: #666; line-height: 1.6;">
        <strong>Usage:</strong> Select a cell on the board, then use conservation laws to move pebbles.
        <strong>Spread</strong> mode automatically repeats Left/Up operations to reduce multiples to singletons.
        Use <strong>Undo/Redo</strong> to navigate changes, <strong>Reset</strong> to return to initial state.
      </div>
      <h3>Conservation Laws</h3>
      <div class="conservation-laws">
        <div class="law-row">
          <button class="btn-primary" id="g-left-btn" disabled>‚Üê √óg Left (l)</button>
          <button class="btn-primary" id="g-right-btn" disabled>√óg Right ‚Üí (r)</button>
        </div>
        <div class="law-row">
          <button class="btn-primary" id="h-up-btn" disabled>‚Üë √óh Up (u)</button>
          <button class="btn-primary" id="h-down-btn" disabled>√óh Down ‚Üì (d)</button>
        </div>
        <div class="law-row">
          <button class="btn-primary" id="special-btn" disabled>Basis Law (f)</button>
          <button class="btn-primary" id="reverse-special-btn" disabled>Reverse Basis Law (b)</button>
        </div>
      </div>
      <div style="font-size: 12px; margin-top: 8px; color: #666; line-height: 1.6;">
        <strong>Keyboard shortcuts:</strong> Keys apply operations with 1 pebble. Hold <strong>Shift</strong> to use maximum available pebbles.
      </div>
      <div id="special-info" style="font-size: 12px; margin-top: 8px; color: #666;"></div>
    </div>

    <div class="canvas-container" id="board-container">
      <canvas id="board-canvas"></canvas>
    </div>

    <div class="panel" style="padding: 15px 25px;">
      <div id="x-cycle-display" style="font-size: 14px; color: #333;">Computing x-cycle...</div>
      <div style="margin-top: 10px;">
        <button class="btn-secondary" id="prev-btn">‚Üê Prev</button>
        <button class="btn-secondary" id="next-btn">Next ‚Üí</button>
        <button class="btn-secondary" id="cycle-btn">Cycle</button>
      </div>
    </div>

    <div class="polynomial-panel panel">
      <h2>Polynomial Representation</h2>
      <div id="polynomial-identity" style="margin-bottom: 15px; font-size: 16px; font-weight: 600; color: #555;"></div>
      <div class="polynomial-display" id="polynomial-display">
        No board initialized. Click "Initialize Board" above to start.
      </div>
      <div id="polynomial-status"></div>

      <div style="margin-top: 20px;">
        <div id="k-heading" style="margin-bottom: 15px; font-size: 16px; color: #555;"></div>
        <div class="polynomial-display" id="k-polynomial-display" style="font-size: 14px;">
        </div>
      </div>

      <div style="margin-top: 15px;">
        <div id="d-heading" style="margin-bottom: 15px; font-size: 16px; color: #555;"></div>
        <div class="polynomial-display" id="d-polynomial-display" style="font-size: 14px;">
        </div>
      </div>
    </div>

    <div class="persistence-panel panel">
      <h2>Save & Share</h2>
      <div class="control-grid">
        <button class="btn-secondary" id="copy-url-btn" disabled>üìã Copy URL</button>
        <button class="btn-secondary" id="save-local-btn" disabled>üíæ Save to Browser</button>
        <button class="btn-secondary" id="load-local-btn">üìÅ Load from Browser</button>
        <button class="btn-secondary" id="export-json-btn" disabled>‚¨á Export JSON</button>
        <button class="btn-secondary" id="import-json-btn">‚¨Ü Import JSON</button>
      </div>
      <input type="file" id="json-file-input" accept=".json" style="display: none;">
    </div>
  </div>

  <!-- Modal for numeric input -->
  <div id="input-modal" class="modal">
    <div class="modal-content">
      <h3 id="modal-title">Enter value</h3>
      <p id="modal-description"></p>
      <input type="number" id="modal-input" min="1" value="1">
      <div class="modal-buttons">
        <button class="btn-secondary" id="modal-cancel">Cancel</button>
        <button class="btn-primary" id="modal-confirm">Apply</button>
      </div>
    </div>
  </div>

  <script>
    'use strict';

    // ========== BoardState Class ==========
    class BoardState {
      constructor(o, e, g, h, q, x0) {
        this.o = o;
        this.e = e;
        this.g = g;
        this.h = h;
        this.q = q;
        this.x0 = x0;
        this.grid = new Map();
        this.minCol = -1;
        this.maxCol = o - 1;
        this.minRow = 0;
        this.maxRow = e;
      }

      get(j, i) {
        const key = `${j},${i}`;
        return this.grid.get(key) || 0;
      }

      set(j, i, count) {
        const key = `${j},${i}`;
        if (count === 0) {
          this.grid.delete(key);
        } else {
          this.grid.set(key, count);
        }
      }

      add(j, i, count) {
        this.set(j, i, this.get(j, i) + count);
      }

      clone() {
        const newBoard = new BoardState(this.o, this.e, this.g, this.h, this.q, this.x0);
        newBoard.grid = new Map(this.grid);
        return newBoard;
      }

      isZeroState() {
        for (const [, count] of this.grid) {
          if (count !== 0) return false;
        }
        return true;
      }

      // Calculate the polynomial sum: Œ£ c_{j,i} * g^{o-1-j} * h^i
      calculatePolynomialSum() {
        let sum = 0;
        for (const [key, count] of this.grid.entries()) {
          const [j, i] = key.split(',').map(Number);
          const gPower = this.o - 1 - j;
          const hPower = i;
          const term = count * Math.pow(this.g, gPower) * Math.pow(this.h, hPower);
          sum += term;
        }
        return sum;
      }

      getPolynomial() {
        const terms = [];
        for (const [key, count] of this.grid) {
          const [j, i] = key.split(',').map(Number);
          const gPower = this.o - 1 - j;
          const hPower = i;
          terms.push({ coeff: count, gPower, hPower, j, i });
        }
        return terms.sort((a, b) => {
          if (b.gPower !== a.gPower) return b.gPower - a.gPower;
          return a.hPower - b.hPower;
        });
      }

      toJSON() {
        // Get current p value from input field
        const p = parseP(document.getElementById('input-p').value);
        const b = p > 0 ? '0b' + p.toString(2) : '';
        const oe = p > 0 ? toOENotation(p) : '';

        return {
          p: p,
          b: b,
          oe: oe,
          o: this.o,
          e: this.e,
          g: this.g,
          h: this.h,
          q: this.q,
          x0: this.x0,
          grid: Array.from(this.grid.entries())
        };
      }

      static fromJSON(json) {
        const board = new BoardState(json.o, json.e, json.g, json.h, json.q, json.x0);
        board.grid = new Map(json.grid);

        // Restore p value to input field if present
        if (json.p) {
          document.getElementById('input-p').value = json.p;
          updateBinaryDisplay();
        }

        return board;
      }
    }

    // ========== History Class ==========
    class History {
      constructor() {
        this.states = [];
        this.currentIndex = -1;
        this.maxSize = 100;
      }

      push(state) {
        this.states = this.states.slice(0, this.currentIndex + 1);
        this.states.push(state.clone());
        if (this.states.length > this.maxSize) {
          this.states.shift();
        } else {
          this.currentIndex++;
        }
      }

      canUndo() {
        return this.currentIndex > 0;
      }

      canRedo() {
        return this.currentIndex < this.states.length - 1;
      }

      undo() {
        if (this.canUndo()) {
          this.currentIndex--;
          return this.states[this.currentIndex].clone();
        }
        return null;
      }

      redo() {
        if (this.canRedo()) {
          this.currentIndex++;
          return this.states[this.currentIndex].clone();
        }
        return null;
      }

      clear() {
        this.states = [];
        this.currentIndex = -1;
      }
    }

    // ========== Renderer Class ==========
    class Renderer {
      constructor(canvas, board) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.board = board;
        this.cellSize = 60;
        this.padding = 50;
        this.pebbleRadius = 8;
        this.maxPebblesPerCell = 10;
        this.selectedCell = null;
        this.hoveredCell = null;

        this.colors = {
          gridLine: '#cccccc',
          cellSelected: '#fff9db',
          cellHover: '#e0f2fe',
          whitePebble: '#ffffff',
          whitePebbleStroke: '#333333',
          blackPebble: '#1f2937',
          blackPebbleStroke: '#666666',
          text: '#333333'
        };
      }

      calculateDimensions() {
        const cols = this.board.maxCol - this.board.minCol + 1;
        const rows = this.board.maxRow - this.board.minRow + 1;
        return {
          width: cols * this.cellSize + 2 * this.padding,
          height: rows * this.cellSize + 2 * this.padding
        };
      }

      gridToPixel(j, i) {
        const x = this.padding + (j - this.board.minCol) * this.cellSize;
        const y = this.padding + (this.board.maxRow - i) * this.cellSize;
        return { x, y };
      }

      pixelToGrid(x, y) {
        const j = Math.floor((x - this.padding) / this.cellSize) + this.board.minCol;
        const i = this.board.maxRow - Math.floor((y - this.padding) / this.cellSize);

        if (j >= this.board.minCol && j <= this.board.maxCol &&
            i >= this.board.minRow && i <= this.board.maxRow) {
          return { j, i };
        }
        return null;
      }

      render() {
        const dims = this.calculateDimensions();
        if (this.canvas.width !== dims.width || this.canvas.height !== dims.height) {
          this.canvas.width = dims.width;
          this.canvas.height = dims.height;
        }

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        this.drawGrid();

        if (this.hoveredCell && (!this.selectedCell || this.hoveredCell.j !== this.selectedCell.j || this.hoveredCell.i !== this.selectedCell.i)) {
          this.highlightCell(this.hoveredCell.j, this.hoveredCell.i, this.colors.cellHover);
        }

        if (this.selectedCell) {
          this.highlightCell(this.selectedCell.j, this.selectedCell.i, this.colors.cellSelected);
        }

        for (let i = this.board.minRow; i <= this.board.maxRow; i++) {
          for (let j = this.board.minCol; j <= this.board.maxCol; j++) {
            const count = this.board.get(j, i);
            if (count !== 0) {
              this.drawPebbles(j, i, count);
            }
          }
        }

        this.drawLabels();
      }

      drawGrid() {
        this.ctx.strokeStyle = this.colors.gridLine;
        this.ctx.lineWidth = 1;

        const cols = this.board.maxCol - this.board.minCol + 1;
        const rows = this.board.maxRow - this.board.minRow + 1;

        for (let col = 0; col <= cols; col++) {
          const x = this.padding + col * this.cellSize;
          this.ctx.beginPath();
          this.ctx.moveTo(x, this.padding);
          this.ctx.lineTo(x, this.padding + rows * this.cellSize);
          this.ctx.stroke();
        }

        for (let row = 0; row <= rows; row++) {
          const y = this.padding + row * this.cellSize;
          this.ctx.beginPath();
          this.ctx.moveTo(this.padding, y);
          this.ctx.lineTo(this.padding + cols * this.cellSize, y);
          this.ctx.stroke();
        }
      }

      drawPebbles(j, i, count) {
        const { x, y } = this.gridToPixel(j, i);
        const centerX = x + this.cellSize / 2;
        const centerY = y + this.cellSize / 2;

        const isWhite = count > 0;
        const absCount = Math.abs(count);

        if (absCount <= this.maxPebblesPerCell) {
          this.drawPebblePattern(centerX, centerY, absCount, isWhite);
        } else {
          this.drawPebbleWithCount(centerX, centerY, count, isWhite);
        }
      }

      drawPebblePattern(centerX, centerY, count, isWhite) {
        const patterns = {
          1: [[0, 0]],
          2: [[-0.3, 0], [0.3, 0]],
          3: [[-0.3, -0.3], [0.3, -0.3], [0, 0.3]],
          4: [[-0.3, -0.3], [0.3, -0.3], [-0.3, 0.3], [0.3, 0.3]],
          5: [[-0.3, -0.3], [0.3, -0.3], [0, 0], [-0.3, 0.3], [0.3, 0.3]],
          6: [[-0.3, -0.3], [0, -0.3], [0.3, -0.3], [-0.3, 0.3], [0, 0.3], [0.3, 0.3]],
          7: [[-0.3, -0.3], [0, -0.3], [0.3, -0.3], [0, 0], [-0.3, 0.3], [0, 0.3], [0.3, 0.3]],
          8: [[-0.3, -0.3], [0, -0.3], [0.3, -0.3], [-0.3, 0], [0.3, 0], [-0.3, 0.3], [0, 0.3], [0.3, 0.3]],
          9: [[-0.3, -0.3], [0, -0.3], [0.3, -0.3], [-0.3, 0], [0, 0], [0.3, 0], [-0.3, 0.3], [0, 0.3], [0.3, 0.3]],
          10: [[-0.35, -0.35], [-0.12, -0.35], [0.12, -0.35], [0.35, -0.35], [-0.35, 0], [0.35, 0], [-0.35, 0.35], [-0.12, 0.35], [0.12, 0.35], [0.35, 0.35]]
        };

        const pattern = patterns[count] || patterns[1];
        const scale = this.cellSize * 0.3;

        pattern.forEach(([dx, dy]) => {
          const px = centerX + dx * scale;
          const py = centerY + dy * scale;
          this.drawSinglePebble(px, py, isWhite);
        });
      }

      drawSinglePebble(x, y, isWhite) {
        this.ctx.beginPath();
        this.ctx.arc(x, y, this.pebbleRadius, 0, 2 * Math.PI);

        if (isWhite) {
          this.ctx.fillStyle = this.colors.whitePebble;
          this.ctx.fill();
          this.ctx.strokeStyle = this.colors.whitePebbleStroke;
          this.ctx.lineWidth = 2;
          this.ctx.stroke();
        } else {
          this.ctx.fillStyle = this.colors.blackPebble;
          this.ctx.fill();
          this.ctx.strokeStyle = this.colors.blackPebbleStroke;
          this.ctx.lineWidth = 1;
          this.ctx.stroke();
        }
      }

      drawPebbleWithCount(x, y, count, isWhite) {
        const radius = this.cellSize * 0.35;

        this.ctx.beginPath();
        this.ctx.arc(x, y, radius, 0, 2 * Math.PI);

        if (isWhite) {
          this.ctx.fillStyle = this.colors.whitePebble;
          this.ctx.fill();
          this.ctx.strokeStyle = this.colors.whitePebbleStroke;
          this.ctx.lineWidth = 2;
          this.ctx.stroke();
          this.ctx.fillStyle = this.colors.text;
        } else {
          this.ctx.fillStyle = this.colors.blackPebble;
          this.ctx.fill();
          this.ctx.strokeStyle = this.colors.blackPebbleStroke;
          this.ctx.lineWidth = 1;
          this.ctx.stroke();
          this.ctx.fillStyle = this.colors.whitePebble;
        }

        this.ctx.font = 'bold 14px sans-serif';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(Math.abs(count).toString(), x, y);
      }

      highlightCell(j, i, color) {
        const { x, y } = this.gridToPixel(j, i);
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);
      }

      drawLabels() {
        this.ctx.fillStyle = this.colors.text;
        this.ctx.font = '12px sans-serif';

        const cols = this.board.maxCol - this.board.minCol + 1;
        const rows = this.board.maxRow - this.board.minRow + 1;
        const gridBottom = this.padding + rows * this.cellSize;
        const gridMiddleX = this.padding + (cols * this.cellSize) / 2;
        const gridMiddleY = this.padding + (rows * this.cellSize) / 2;

        // Horizontal axis - column numbers at bottom
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'top';
        for (let j = this.board.minCol; j <= this.board.maxCol; j++) {
          const { x } = this.gridToPixel(j, 0);
          this.ctx.fillText(j.toString(), x + this.cellSize / 2, gridBottom + 5);
        }

        // "j" axis label at bottom center
        this.ctx.font = 'italic 14px sans-serif';
        this.ctx.fillText('j', gridMiddleX, gridBottom + 28);
        this.ctx.font = '12px sans-serif';

        // Vertical axis - row numbers on left
        this.ctx.textAlign = 'right';
        this.ctx.textBaseline = 'middle';
        for (let i = this.board.minRow; i <= this.board.maxRow; i++) {
          const { y } = this.gridToPixel(0, i);
          this.ctx.fillText(i.toString(), this.padding - 10, y + this.cellSize / 2);
        }

        // "i" axis label on left center
        this.ctx.textAlign = 'center';
        this.ctx.font = 'italic 14px sans-serif';
        this.ctx.fillText('i', this.padding / 3, gridMiddleY);
      }
    }

    // ========== ConservationLaws Class ==========
    class ConservationLaws {
      constructor(board) {
        this.board = board;
      }

      canApplyGMultiplyRight(j, i) {
        return j < this.board.maxCol && this.board.get(j, i) !== 0;
      }

      applyGMultiplyRight(j, i, numPebbles) {
        if (!this.canApplyGMultiplyRight(j, i)) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (numPebbles > absAvailable) return false;

        this.board.add(j, i, -sign * numPebbles);
        this.board.add(j + 1, i, sign * this.board.g * numPebbles);

        return true;
      }

      canApplyGMultiplyLeft(j, i) {
        if (j >= this.board.maxCol) return false;
        const count = this.board.get(j + 1, i);
        return Math.abs(count) >= this.board.g;
      }

      applyGMultiplyLeft(j, i, numSets) {
        if (!this.canApplyGMultiplyLeft(j, i)) return false;

        const count = this.board.get(j + 1, i);
        const sign = Math.sign(count);
        const maxSets = Math.floor(Math.abs(count) / this.board.g);

        if (numSets > maxSets) return false;

        this.board.add(j + 1, i, -sign * this.board.g * numSets);
        this.board.add(j, i, sign * numSets);

        return true;
      }

      canApplyHMultiplyDown(j, i) {
        return i > this.board.minRow && this.board.get(j, i) !== 0;
      }

      applyHMultiplyDown(j, i, numPebbles) {
        if (!this.canApplyHMultiplyDown(j, i)) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (numPebbles > absAvailable) return false;

        // Move DOWN: 1 pebble at (j, i) becomes h pebbles at (j, i-1)
        this.board.add(j, i, -sign * numPebbles);
        this.board.add(j, i - 1, sign * this.board.h * numPebbles);

        return true;
      }

      canApplyHMultiplyUp(j, i) {
        if (i >= this.board.maxRow) return false;
        const count = this.board.get(j, i);
        return Math.abs(count) >= this.board.h;
      }

      applyHMultiplyUp(j, i, numSets) {
        if (!this.canApplyHMultiplyUp(j, i)) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const maxSets = Math.floor(Math.abs(count) / this.board.h);

        if (numSets > maxSets) return false;

        // Move UP: h pebbles at (j, i) becomes 1 pebble at (j, i+1)
        this.board.add(j, i, -sign * this.board.h * numSets);
        this.board.add(j, i + 1, sign * numSets);

        return true;
      }

      // Special Collatz relations
      is3x1System() {
        return this.board.g === this.board.h * this.board.h - 1;
      }

      is5x1System() {
        return this.board.g === this.board.h * this.board.h + this.board.h - 1;
      }

      getSpecialSystemType() {
        if (this.is3x1System()) return '3x+1';
        if (this.is5x1System()) return '5x+1';
        return null;
      }

      canApplySpecial(j, i) {
        if (!this.is3x1System() && !this.is5x1System()) return false;
        if (this.board.get(j, i) === 0) return false;
        if (j >= this.board.maxCol) return false;

        if (this.is3x1System()) {
          return i + 2 <= this.board.maxRow;
        } else if (this.is5x1System()) {
          return i + 2 <= this.board.maxRow;
        }

        return false;
      }

      applySpecial3x1(j, i, numPebbles) {
        if (!this.is3x1System()) return false;
        if (j >= this.board.maxCol || i + 2 > this.board.maxRow) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (numPebbles > absAvailable) return false;

        // For 3x+1 (g = h¬≤ - 1):
        // Remove pebble from (j, i)
        // Add same color pebble at (j+1, i+2)
        // Add opposite color pebble at (j+1, i)
        this.board.add(j, i, -sign * numPebbles);
        this.board.add(j + 1, i + 2, sign * numPebbles);
        this.board.add(j + 1, i, -sign * numPebbles);

        return true;
      }

      applySpecial5x1(j, i, numPebbles) {
        if (!this.is5x1System()) return false;
        if (j >= this.board.maxCol || i + 2 > this.board.maxRow) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (numPebbles > absAvailable) return false;

        // For 5x+1 (g = h¬≤ + h - 1):
        // Remove pebble from (j, i)
        // Add same color pebbles at (j+1, i+2) and (j+1, i+1)
        // Add opposite color pebble at (j+1, i)
        this.board.add(j, i, -sign * numPebbles);
        this.board.add(j + 1, i + 2, sign * numPebbles);
        this.board.add(j + 1, i + 1, sign * numPebbles);
        this.board.add(j + 1, i, -sign * numPebbles);

        return true;
      }

      applySpecial(j, i, numPebbles) {
        if (this.is3x1System()) {
          return this.applySpecial3x1(j, i, numPebbles);
        } else if (this.is5x1System()) {
          return this.applySpecial5x1(j, i, numPebbles);
        }
        return false;
      }

      // Reverse of applySpecial3x1: h¬≤ = g + 1
      // Using h^i = h^(i-2) ¬∑ (g + 1) = g¬∑h^(i-2) + h^(i-2)
      applyReverseSpecial3x1(j, i, numPebbles) {
        if (!this.is3x1System()) return false;
        if (j <= this.board.minCol || i < 2) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (sign === 0 || numPebbles > absAvailable) return false;

        // For 3x+1 (g = h¬≤ - 1), reverse means: h¬≤ = g + 1
        // g^(o-1-j)¬∑h^i = g^(o-j)¬∑h^(i-2) + g^(o-1-j)¬∑h^(i-2)
        this.board.add(j, i, -sign * numPebbles);          // remove from source
        this.board.add(j - 1, i - 2, sign * numPebbles);   // g¬∑h^(i-2) term
        this.board.add(j, i - 2, sign * numPebbles);       // h^(i-2) constant term

        return true;
      }

      // Reverse of applySpecial5x1: h¬≤ = g - h + 1
      // Using h^i = h^(i-2) ¬∑ (g - h + 1) = g¬∑h^(i-2) - h^(i-1) + h^(i-2)
      applyReverseSpecial5x1(j, i, numPebbles) {
        if (!this.is5x1System()) return false;
        if (j <= this.board.minCol || i < 2) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (sign === 0 || numPebbles > absAvailable) return false;

        // For 5x+1 (g = h¬≤ + h - 1), reverse means: h¬≤ = g - h + 1
        // g^(o-1-j)¬∑h^i = g^(o-j)¬∑h^(i-2) - g^(o-1-j)¬∑h^(i-1) + g^(o-1-j)¬∑h^(i-2)
        this.board.add(j, i, -sign * numPebbles);          // remove from source
        this.board.add(j - 1, i - 2, sign * numPebbles);   // g¬∑h^(i-2) term
        this.board.add(j, i - 1, -sign * numPebbles);      // -h^(i-1) term
        this.board.add(j, i - 2, sign * numPebbles);       // h^(i-2) constant term

        return true;
      }

      applyReverseSpecial(j, i, numPebbles) {
        if (this.is3x1System()) {
          return this.applyReverseSpecial3x1(j, i, numPebbles);
        } else if (this.is5x1System()) {
          return this.applyReverseSpecial5x1(j, i, numPebbles);
        }
        return false;
      }

      canApplyReverseSpecial(j, i) {
        if (j <= this.board.minCol || i < 2) return false;

        const count = this.board.get(j, i);
        if (Math.sign(count) === 0) return false;

        return this.is3x1System() || this.is5x1System();
      }
    }

    // ========== Persistence Class ==========
    class Persistence {
      constructor(app) {
        this.app = app;
        this.storageKey = 'othello-collatz-boards';
      }

      generateURL() {
        const state = this.app.board.toJSON();
        const encoded = btoa(JSON.stringify(state));
        const url = new URL(window.location.href);
        url.searchParams.set('state', encoded);
        return url.toString();
      }

      loadFromURL() {
        const url = new URL(window.location.href);
        const encoded = url.searchParams.get('state');

        if (encoded) {
          try {
            const json = JSON.parse(atob(encoded));
            const board = BoardState.fromJSON(json);
            this.app.board = board;
            this.app.laws = new ConservationLaws(board);
            this.app.renderer.board = board;
            this.app.history.clear();
            this.app.history.push(board);
            this.app.initialBoard = board.clone();
            this.app.render();
            return true;
          } catch (e) {
            console.error('Failed to load state from URL:', e);
            return false;
          }
        }

        return false;
      }

      copyURL() {
        const url = this.generateURL();
        navigator.clipboard.writeText(url).then(() => {
          alert('‚úì URL copied to clipboard! Share this link to save your board configuration.');
        }).catch(err => {
          console.error('Failed to copy URL:', err);
          alert('Failed to copy URL. Please copy manually from the address bar.');
        });
      }

      saveToLocalStorage() {
        const name = prompt('Enter a name for this configuration:', `Config-${Date.now()}`);
        if (!name) return;

        const saved = this.getSavedBoards();
        saved[name] = {
          timestamp: Date.now(),
          state: this.app.board.toJSON()
        };
        localStorage.setItem(this.storageKey, JSON.stringify(saved));
        alert(`‚úì Configuration saved as "${name}"`);
      }

      loadFromLocalStorage() {
        const saved = this.getSavedBoards();
        const names = Object.keys(saved);

        if (names.length === 0) {
          alert('No saved configurations found.');
          return;
        }

        const name = prompt(`Enter configuration name to load:\n\nAvailable: ${names.join(', ')}`);
        if (!name || !saved[name]) {
          alert('Configuration not found.');
          return;
        }

        const board = BoardState.fromJSON(saved[name].state);
        this.app.board = board;
        this.app.laws = new ConservationLaws(board);
        this.app.renderer.board = board;
        this.app.history.clear();
        this.app.history.push(board);
        this.app.initialBoard = board.clone();
        this.app.render();
      }

      getSavedBoards() {
        const saved = localStorage.getItem(this.storageKey);
        return saved ? JSON.parse(saved) : {};
      }

      exportJSON() {
        const state = this.app.board.toJSON();
        const json = JSON.stringify(state, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `othello-collatz-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      importJSON(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();

          reader.onload = (e) => {
            try {
              const json = JSON.parse(e.target.result);
              const board = BoardState.fromJSON(json);
              this.app.board = board;
              this.app.laws = new ConservationLaws(board);
              this.app.renderer.board = board;
              this.app.history.clear();
              this.app.history.push(board);
              this.app.initialBoard = board.clone();
              this.app.render();
              resolve(true);
            } catch (err) {
              reject(err);
            }
          };

          reader.onerror = reject;
          reader.readAsText(file);
        });
      }
    }

    // ========== Application Class ==========
    class Application {
      constructor() {
        this.board = null;
        this.history = new History();
        this.renderer = null;
        this.laws = null;
        this.selectedCell = null;
        this.initialBoard = null;
        this.pendingAction = null;
      }

      initialize(o, e, g, h, q, x0) {
        if (o < 0 || e < 0 || g < 2 || h < 2 || q === 0 || x0 === 0) {
          throw new Error('Invalid parameters: o, e must be non-negative; g, h must be at least 2; q and x0 must be non-zero');
        }

        this.board = new BoardState(o, e, g, h, q, x0);
        this.generateInitialState();

        const canvas = document.getElementById('board-canvas');
        this.renderer = new Renderer(canvas, this.board);
        this.laws = new ConservationLaws(this.board);

        this.initialBoard = this.board.clone();
        this.history.clear();
        this.history.push(this.board);

        this.selectedCell = null;
        this.render();
        this.enableButtons();
      }

      generateInitialState() {
        // Get the current p value and parse its structure
        const pInput = document.getElementById('input-p');
        if (!pInput) {
          // Fallback if input doesn't exist
          this.board.set(-1, 0, this.board.x0);
          this.board.set(this.board.o - 1, this.board.e, -this.board.x0);
          return;
        }

        const p = parseP(pInput.value);
        if (isNaN(p) || p <= 0) {
          // Fallback to simple initialization
          this.board.set(-1, 0, this.board.x0);
          this.board.set(this.board.o - 1, this.board.e, -this.board.x0);
          return;
        }

        try {
          // Use the correct parsing function that handles even p values
          const { monomials } = parseBinaryToStructure(p);

          // Place x‚ÇÄ term at the start: x‚ÇÄ¬∑g^o at position (-1, 0)
          this.board.set(-1, 0, this.board.x0);

          // Place q coefficient for each monomial in k(g,h)
          for (const m of monomials) {
            const j = this.board.o - 1 - m.gPower;
            const i = m.hPower;
            this.board.set(j, i, this.board.q);
          }

          // Place -x‚ÇÄ term at the end: -x‚ÇÄ¬∑h^e at position (o-1, e)
          this.board.set(this.board.o - 1, this.board.e, -this.board.x0);

        } catch (err) {
          console.error('Error generating initial state:', err);
          // Fallback
          this.board.set(-1, 0, this.board.x0);
          this.board.set(this.board.o - 1, this.board.e, -this.board.x0);
        }
      }

      applyAction(actionFn, successMessage) {
        // Calculate polynomial sum before action
        const sumBefore = this.board.calculatePolynomialSum();

        const newBoard = this.board.clone();
        const newLaws = new ConservationLaws(newBoard);

        if (actionFn(newLaws)) {
          // Calculate polynomial sum after action
          const sumAfter = newBoard.calculatePolynomialSum();

          // Assert that the polynomial sum is preserved
          const tolerance = 1e-9; // Account for floating point errors
          if (Math.abs(sumBefore - sumAfter) > tolerance) {
            console.error('ASSERTION FAILED: Polynomial sum not preserved!');
            console.error(`Before: ${sumBefore}`);
            console.error(`After: ${sumAfter}`);
            console.error(`Difference: ${sumAfter - sumBefore}`);
            alert(`‚ö†Ô∏è Conservation law violation detected!\n\nPolynomial sum before: ${sumBefore}\nPolynomial sum after: ${sumAfter}\n\nThis action has been blocked.`);
            return false;
          }

          this.board = newBoard;
          this.laws = newLaws;
          this.renderer.board = newBoard;
          this.history.push(this.board);

          if (this.board.isZeroState()) {
            setTimeout(() => {
              alert('üéâ Zero state reached! The cycle has been proven.\n\nAll pebbles have been cancelled through conservation laws.');
            }, 100);
          }

          this.render();
          return true;
        }

        return false;
      }

      undo() {
        const prevBoard = this.history.undo();
        if (prevBoard) {
          this.board = prevBoard;
          this.laws = new ConservationLaws(this.board);
          this.renderer.board = this.board;
          this.render();
        }
      }

      redo() {
        const nextBoard = this.history.redo();
        if (nextBoard) {
          this.board = nextBoard;
          this.laws = new ConservationLaws(this.board);
          this.renderer.board = this.board;
          this.render();
        }
      }

      reset() {
        if (this.initialBoard) {
          this.board = this.initialBoard.clone();
          this.laws = new ConservationLaws(this.board);
          this.renderer.board = this.board;
          this.history.clear();
          this.history.push(this.board);
          this.selectedCell = null;
          this.renderer.selectedCell = null;
          this.render();
        }
      }

      render() {
        if (this.renderer) {
          this.renderer.render();
        }
        this.updatePolynomialDisplay();
        this.updateControlPanel();
      }

      updatePolynomialDisplay() {
        const terms = this.board.getPolynomial();
        const latexStr = this.formatPolynomialLatex(terms);
        const displayElement = document.getElementById('polynomial-display');

        // Render identity equation
        const identityElement = document.getElementById('polynomial-identity');
        const identityLatex = 'p(g,h) = q \\cdot k(g,h) - x_0 \\cdot d(g,h) = 0';
        try {
          katex.render(identityLatex, identityElement, {
            throwOnError: false,
            displayMode: false
          });
        } catch (e) {
          console.error('KaTeX identity rendering error:', e);
          identityElement.textContent = 'p(g,h) = q¬∑k(g,h) - x‚ÇÄ¬∑d(g,h) = 0';
        }

        // Render polynomial using KaTeX
        try {
          katex.render(latexStr, displayElement, {
            throwOnError: false,
            displayMode: true
          });
        } catch (e) {
          console.error('KaTeX rendering error:', e);
          displayElement.textContent = this.formatPolynomial(terms);
        }

        // Render k(g,h) polynomial
        this.renderKPolynomial();

        // Render d(g,h) polynomial
        this.renderDPolynomial();

        const statusDiv = document.getElementById('polynomial-status');
        if (this.board.isZeroState()) {
          statusDiv.innerHTML = '<span class="status-badge status-zero">‚úì Zero state reached!</span>';
        } else {
          const nonZero = terms.filter(t => t.coeff !== 0).length;
          statusDiv.innerHTML = `<span class="status-badge status-active">${nonZero} non-zero term${nonZero !== 1 ? 's' : ''}</span>`;
        }
      }

      renderKPolynomial() {
        const p = parseP(document.getElementById('input-p').value);
        if (isNaN(p) || p <= 0) return;

        // Render heading
        const headingElement = document.getElementById('k-heading');
        try {
          katex.render('k(g,h)', headingElement, {
            throwOnError: false,
            displayMode: false
          });
        } catch (e) {
          headingElement.textContent = 'k(g,h)';
        }

        try {
          const structure = parseBinaryToStructure(p);
          const monomials = structure.monomials;

          // Format k(g,h) as sum of monomials
          const parts = monomials.map((m, idx) => {
            const sign = idx === 0 ? '' : ' + ';
            let term = '';
            if (m.gPower > 0) {
              term += 'g';
              if (m.gPower > 1) term += '^{' + m.gPower + '}';
            }
            if (m.hPower > 0) {
              term += 'h';
              if (m.hPower > 1) term += '^{' + m.hPower + '}';
            }
            if (term === '') term = '1';
            return sign + term;
          });

          const latexStr = parts.join('');
          const displayElement = document.getElementById('k-polynomial-display');

          katex.render(latexStr, displayElement, {
            throwOnError: false,
            displayMode: true
          });
        } catch (e) {
          console.error('Error rendering k(g,h):', e);
        }
      }

      renderDPolynomial() {
        const o = parseInt(document.getElementById('output-o').textContent);
        const e = parseInt(document.getElementById('output-e').textContent);

        if (isNaN(o) || isNaN(e)) return;

        // Render heading
        const headingElement = document.getElementById('d-heading');
        try {
          katex.render('d(g,h)', headingElement, {
            throwOnError: false,
            displayMode: false
          });
        } catch (e) {
          headingElement.textContent = 'd(g,h)';
        }

        // Format d(g,h) = h^e - g^o
        let latexStr = '';
        if (e > 0) {
          latexStr += 'h';
          if (e > 1) latexStr += '^{' + e + '}';
        } else {
          latexStr += '1';
        }

        latexStr += ' - ';

        if (o > 0) {
          latexStr += 'g';
          if (o > 1) latexStr += '^{' + o + '}';
        } else {
          latexStr += '1';
        }

        const displayElement = document.getElementById('d-polynomial-display');

        try {
          katex.render(latexStr, displayElement, {
            throwOnError: false,
            displayMode: true
          });
        } catch (e) {
          console.error('Error rendering d(g,h):', e);
        }
      }

      formatPolynomial(terms) {
        if (terms.length === 0) return '0';

        const parts = terms
          .filter(t => t.coeff !== 0)
          .map((t, idx) => {
            const sign = t.coeff > 0 ? (idx === 0 ? '' : ' + ') : ' - ';
            const absCoeff = Math.abs(t.coeff);
            const coeffStr = absCoeff === 1 && (t.gPower > 0 || t.hPower > 0) ? '' : absCoeff.toString();

            let term = coeffStr;
            if (t.gPower > 0) {
              term += 'g';
              if (t.gPower > 1) term += '^' + t.gPower;
            }
            if (t.hPower > 0) {
              term += 'h';
              if (t.hPower > 1) term += '^' + t.hPower;
            }
            if (term === '') term = '1';

            if (t.gPower === 0 && t.hPower === 0 && (t.j !== -1 || t.i !== 0)) {
              term += 'q';
            }

            return sign + term + " = 0";
          });

        return parts.join('') || '0';
      }

      formatPolynomialLatex(terms) {
        if (terms.length === 0) return '0 = 0';

        const parts = terms
          .filter(t => t.coeff !== 0)
          .map((t, idx) => {
            const sign = t.coeff > 0 ? (idx === 0 ? '' : ' + ') : ' - ';
            const absCoeff = Math.abs(t.coeff);
            const coeffStr = absCoeff === 1 && (t.gPower > 0 || t.hPower > 0) ? '' : absCoeff.toString();

            let term = coeffStr;
            if (t.gPower > 0) {
              term += 'g';
              if (t.gPower > 1) term += '^{' + t.gPower + '}';
            }
            if (t.hPower > 0) {
              term += 'h';
              if (t.hPower > 1) term += '^{' + t.hPower + '}';
            }
            if (term === '') term = '1';

            if (t.gPower === 0 && t.hPower === 0 && (t.j !== -1 || t.i !== 0)) {
              term += 'q';
            }

            return sign + term;
          });

        return parts.join('') + ' = 0' || '0 = 0';
      }

      updateControlPanel() {
        document.getElementById('undo-btn').disabled = !this.history.canUndo();
        document.getElementById('redo-btn').disabled = !this.history.canRedo();

        // Update special system info
        const specialType = this.laws.getSpecialSystemType();
        const specialInfo = document.getElementById('special-info');
        if (specialType) {
          specialInfo.innerHTML = `<strong>Special System Detected:</strong> ${specialType} (g=${this.board.g}, h=${this.board.h})`;
        } else {
          specialInfo.innerHTML = `<em>No special Collatz relation detected (g‚â†h¬≤-1 and g‚â†h¬≤+h-1)</em>`;
        }

        if (this.selectedCell) {
          const { j, i } = this.selectedCell;
          const count = this.board.get(j, i);
          const color = count > 0 ? 'white' : 'black';
          const gPower = this.board.o - 1 - j;
          const hPower = i;

          document.getElementById('selected-info').innerHTML =
            `Selected: (j=${j}, i=${i}) | ${Math.abs(count)} ${color} pebble${Math.abs(count) !== 1 ? 's' : ''} | Term: g^${gPower}¬∑h^${hPower}`;

          document.getElementById('g-right-btn').disabled = !this.laws.canApplyGMultiplyRight(j, i);
          document.getElementById('g-left-btn').disabled = (j <= this.board.minCol) || !this.laws.canApplyGMultiplyLeft(j - 1, i);
          document.getElementById('h-down-btn').disabled = !this.laws.canApplyHMultiplyDown(j, i);
          document.getElementById('h-up-btn').disabled = !this.laws.canApplyHMultiplyUp(j, i);
          document.getElementById('special-btn').disabled = !this.laws.canApplySpecial(j, i);
          document.getElementById('reverse-special-btn').disabled = !this.laws.canApplyReverseSpecial(j, i);
        } else {
          document.getElementById('selected-info').textContent = 'No cell selected. Click a cell on the board to select it.';
          document.getElementById('g-right-btn').disabled = true;
          document.getElementById('g-left-btn').disabled = true;
          document.getElementById('h-down-btn').disabled = true;
          document.getElementById('h-up-btn').disabled = true;
          document.getElementById('special-btn').disabled = true;
          document.getElementById('reverse-special-btn').disabled = true;
        }
      }

      enableButtons() {
        document.getElementById('reset-btn').disabled = false;
        document.getElementById('copy-url-btn').disabled = false;
        document.getElementById('save-local-btn').disabled = false;
        document.getElementById('export-json-btn').disabled = false;
      }

      showInputModal(title, description, max, callback, defaultValue = 1) {
        const modal = document.getElementById('input-modal');
        const input = document.getElementById('modal-input');

        document.getElementById('modal-title').textContent = title;
        document.getElementById('modal-description').textContent = description;
        input.value = Math.min(defaultValue, max);
        input.max = max;

        modal.classList.add('active');
        input.focus();

        const confirm = () => {
          const value = parseInt(input.value);
          if (value > 0 && value <= max) {
            modal.classList.remove('active');
            callback(value);
          }
        };

        const cancel = () => {
          modal.classList.remove('active');
        };

        document.getElementById('modal-confirm').onclick = confirm;
        document.getElementById('modal-cancel').onclick = cancel;

        input.onkeypress = (e) => {
          if (e.key === 'Enter') confirm();
          if (e.key === 'Escape') cancel();
        };
      }
    }

    // ========== Initialize Application ==========
    const app = new Application();
    const persistence = new Persistence(app);

    // Parse p input (accepts decimal, binary "0b1011", or OE notation "OEEOEE")
    function parseP(value) {
      if (typeof value === 'string') {
        value = value.trim();

        // Check for binary string like "0b1011"
        if (value.startsWith('0b') || value.startsWith('0B')) {
          return parseInt(value.substring(2), 2);
        }

        // Check for OE notation like "OEEEOEEOEE"
        // O = odd bit (1), E = even bit (0)
        // Leftmost symbol is LSB, no stop bit included
        if (/^[OE]+$/i.test(value)) {
          let bits = '';
          // Convert OE to binary (left to right = LSB to MSB)
          for (let i = 0; i < value.length; i++) {
            bits += (value[i].toUpperCase() === 'O') ? '1' : '0';
          }
          // Add stop bit at the end (highest bit)
          bits += '1';
          // Reverse to convert from LSB-first to MSB-first (standard binary)
          bits = bits.split('').reverse().join('');
          return parseInt(bits, 2);
        }
      }

      // Regular integer
      return parseInt(value, 10);
    }

    // Update URL query parameters to reflect current p, g, h values
    function updateURLParams() {
      const p = document.getElementById('input-p').value;
      const g = document.getElementById('input-g').value;
      const h = document.getElementById('input-h').value;

      const url = new URL(window.location.href);
      // Remove old state parameter if present (query params take precedence)
      url.searchParams.delete('state');
      // Remove anchor when manually changing inputs (will be reset to current p on next display)
      url.searchParams.delete('anchor');
      url.searchParams.set('p', p);
      url.searchParams.set('g', g);
      url.searchParams.set('h', h);

      // Update URL without reloading the page
      window.history.replaceState({}, '', url);
    }

    // Update binary representation
    // Convert p to OE notation
    function toOENotation(p) {
      const binary = p.toString(2);
      const bits = binary.split('').reverse(); // LSB first
      let oe = '';
      // Skip the stop bit (highest bit)
      for (let i = 0; i < bits.length - 1; i++) {
        oe += bits[i] === '1' ? 'O' : 'E';
      }
      return oe;
    }

    function updateBinaryDisplay() {
      const p = parseP(document.getElementById('input-p').value);
      if (!isNaN(p) && p > 0) {
        const pValue = p;
        const bValue = '0b' + p.toString(2);
        const oeValue = toOENotation(p);

        const pLink = document.getElementById('output-p');
        const bLink = document.getElementById('output-b');
        const oeLink = document.getElementById('output-oe');

        pLink.textContent = pValue;
        bLink.textContent = bValue;
        oeLink.textContent = oeValue;

        // Update link hrefs to use the respective p format
        const g = document.getElementById('input-g').value;
        const h = document.getElementById('input-h').value;
        pLink.href = `?p=${pValue}&g=${g}&h=${h}`;
        bLink.href = `?p=${bValue}&g=${g}&h=${h}`;
        oeLink.href = `?p=${oeValue}&g=${g}&h=${h}`;
      }
    }

    // Parse binary parameter p to extract cycle structure
    function parseBinaryToStructure(p) {
      const binary = p.toString(2);
      const bits = binary.split('').reverse(); // Read right to left

      const monomials = [];
      let hExponent = 0;
      let i = 0;

      // Count initial 0s (E bits) for even p values
      while (i < bits.length - 1 && bits[i] === '0') {
        hExponent++;
        i++;
      }

      // Parse monomials from right to left, excluding stop bit
      while (i < bits.length - 1) {
        if (bits[i] === '1') {
          // Record monomial at current h exponent
          monomials.push({ hPower: hExponent });
          i++;

          // Count following even bits (run of 0s)
          let evenCount = 0;
          while (i < bits.length - 1 && bits[i] === '0') {
            evenCount++;
            i++;
          }
          hExponent += evenCount;
        } else {
          // Safety: skip unexpected bits (shouldn't happen in valid patterns)
          i++;
        }
      }

      const o = monomials.length;
      const e = hExponent;

      // Assign g powers (decreasing from o-1 to 0)
      for (let j = 0; j < monomials.length; j++) {
        monomials[j].gPower = o - 1 - j;
      }

      return { o, e, monomials };
    }

    // Compute k(g,h) from monomial structure
    function computeK(monomials, g, h) {
      let sum = 0;
      for (const m of monomials) {
        sum += Math.pow(g, m.gPower) * Math.pow(h, m.hPower);
      }
      return sum;
    }

    // Compute GCD using Euclidean algorithm
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      while (b !== 0) {
        const temp = b;
        b = a % b;
        a = temp;
      }
      return a;
    }

    // Enumerate p-cycle by rotating lower bits
    function enumeratePCycle(p) {
      // Find the position of the stop bit (highest bit)
      const binary = p.toString(2);
      const bitLength = binary.length;
      const stopBitPos = bitLength - 1;
      const stopBitMask = 1 << stopBitPos;
      const lowerBitsMask = stopBitMask - 1;

      const cycle = [];
      let current = p;

      do {
        cycle.push(current);

        // Strip stop bit
        const lowerBits = current & lowerBitsMask;

        // Rotate right: LSB goes to MSB of lower bits (not stop bit position)
        const lsb = lowerBits & 1;
        const rotated = (lowerBits >> 1) | (lsb << (stopBitPos - 1));

        // Add stop bit back
        current = rotated | stopBitMask;

      } while (current !== p);

      return cycle;
    }

    // Calculate x-cycle from p-cycle
    function calculateXCycle(pCycle, g, h) {
      const xCycle = [];

      for (const p of pCycle) {
        try {
          const structure = parseBinaryToStructure(p);
          const k = computeK(structure.monomials, g, h);
          const d = Math.pow(h, structure.e) - Math.pow(g, structure.o);
          const gcdValue = gcd(k, d);
          const x0 = Math.round(k / gcdValue);

          xCycle.push({ p, x0 });
        } catch (err) {
          console.error('Error calculating x for p=' + p, err);
        }
      }

      return xCycle;
    }

    // Display x-cycle below the board
    function displayXCycle() {
      const currentP = parseP(document.getElementById('input-p').value);
      const g = parseInt(document.getElementById('input-g').value);
      const h = parseInt(document.getElementById('input-h').value);

      const container = document.getElementById('x-cycle-display');
      if (!container) return;

      if (isNaN(currentP) || currentP <= 0 || isNaN(g) || g < 2 || isNaN(h) || h < 2) {
        container.innerHTML = '';
        return;
      }

      try {
        // Get anchor from URL or use current p as default
        let url = new URL(window.location.href);
        let anchorP = url.searchParams.has('anchor')
          ? parseInt(url.searchParams.get('anchor'))
          : currentP;

        // If no anchor was set, set it now to preserve cycle order
        if (!url.searchParams.has('anchor')) {
          url.searchParams.set('anchor', anchorP);
          window.history.replaceState({}, '', url);
        }

        // Generate p-cycle from anchor point and calculate corresponding x values
        const pCycle = enumeratePCycle(anchorP);
        const xCycle = calculateXCycle(pCycle, g, h);

        let html = '<strong>x-cycle:</strong> [';

        xCycle.forEach((item, idx) => {
          if (idx > 0) html += ', ';

          // Check if this item's p matches currentP
          const isCurrent = (item.p == currentP);

          if (isCurrent) {
            // Current element - show as plain text, no link
            html += `<span>${item.x0}</span>`;
          } else {
            // Other elements - add clickable link
            html += `<a href="#" class="x-cycle-link" data-p="${item.p}" data-g="${g}" data-h="${h}" data-anchor="${anchorP}" style="cursor:pointer;" title="p=${item.p}">${item.x0}</a>`;
          }
        });

        html += ']';
        container.innerHTML = html;

        // Add click handlers to x-cycle links
        const links = container.querySelectorAll('.x-cycle-link');
        links.forEach(link => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const newP = link.getAttribute('data-p');
            const newG = link.getAttribute('data-g');
            const newH = link.getAttribute('data-h');
            const anchor = link.getAttribute('data-anchor');

            // Update input fields
            document.getElementById('input-p').value = newP;
            document.getElementById('input-g').value = newG;
            document.getElementById('input-h').value = newH;

            // Update derived parameters and display
            updateBinaryDisplay();
            updateDerivedParameters();

            // Update URL without page reload, preserving anchor
            const url = new URL(window.location.href);
            url.searchParams.set('p', newP);
            url.searchParams.set('g', newG);
            url.searchParams.set('h', newH);
            url.searchParams.set('anchor', anchor);
            window.history.pushState({}, '', url);

            // Reinitialize board
            document.getElementById('init-btn').click();
          });
        });
      } catch (err) {
        console.error('Error displaying x-cycle:', err);
        container.innerHTML = '';
      }
    }

    // Cycle animation state
    let cycleInterval = null;

    // Rotate p to next value (rotate right)
    function rotatePNext(p) {
      const binary = p.toString(2);
      const bitLength = binary.length;
      const stopBitPos = bitLength - 1;
      const stopBitMask = 1 << stopBitPos;
      const lowerBitsMask = stopBitMask - 1;

      const lowerBits = p & lowerBitsMask;
      const lsb = lowerBits & 1;
      const rotated = (lowerBits >> 1) | (lsb << (stopBitPos - 1));
      return rotated | stopBitMask;
    }

    // Rotate p to previous value (rotate left)
    function rotatePPrev(p) {
      const binary = p.toString(2);
      const bitLength = binary.length;
      const stopBitPos = bitLength - 1;
      const stopBitMask = 1 << stopBitPos;
      const lowerBitsMask = stopBitMask - 1;

      const lowerBits = p & lowerBitsMask;
      const msb = (lowerBits >> (stopBitPos - 1)) & 1;
      const rotated = ((lowerBits << 1) & lowerBitsMask) | msb;
      return rotated | stopBitMask;
    }

    // Load a new p value and update everything
    function loadP(newP) {
      const g = document.getElementById('input-g').value;
      const h = document.getElementById('input-h').value;

      document.getElementById('input-p').value = newP;
      updateBinaryDisplay();
      updateDerivedParameters();

      const url = new URL(window.location.href);
      url.searchParams.set('p', newP);
      url.searchParams.set('g', g);
      url.searchParams.set('h', h);
      // Preserve anchor if it exists, otherwise set it to the new p
      if (!url.searchParams.has('anchor')) {
        url.searchParams.set('anchor', newP);
      }
      window.history.pushState({}, '', url);

      document.getElementById('init-btn').click();
    }

    // Go to next p-value
    function goToNextP() {
      const p = parseP(document.getElementById('input-p').value);
      const nextP = rotatePNext(p);
      loadP(nextP);
    }

    // Go to previous p-value
    function goToPrevP() {
      const p = parseP(document.getElementById('input-p').value);
      const prevP = rotatePPrev(p);
      loadP(prevP);
    }

    // Toggle cycle animation
    function toggleCycle() {
      const cycleBtn = document.getElementById('cycle-btn');
      if (cycleInterval) {
        // Stop cycling
        clearInterval(cycleInterval);
        cycleInterval = null;
        cycleBtn.textContent = 'Cycle';
      } else {
        // Start cycling
        cycleInterval = setInterval(goToNextP, 1000);
        cycleBtn.textContent = 'Stop';
      }
    }

    // Stop cycle animation if running
    function stopCycle() {
      if (cycleInterval) {
        clearInterval(cycleInterval);
        cycleInterval = null;
        const cycleBtn = document.getElementById('cycle-btn');
        cycleBtn.textContent = 'Cycle';
      }
    }

    // Update derived parameters from p, g, h
    function updateDerivedParameters() {
      const p = parseP(document.getElementById('input-p').value);
      const g = parseInt(document.getElementById('input-g').value);
      const h = parseInt(document.getElementById('input-h').value);

      if (isNaN(p) || p <= 0 || isNaN(g) || g < 2 || isNaN(h) || h < 2) {
        return;
      }

      try {
        // Parse binary structure
        const structure = parseBinaryToStructure(p);
        const o = structure.o;
        const e = structure.e;

        // Compute k(g,h) - cofactor of q
        const k = computeK(structure.monomials, g, h);

        // Compute d(g,h) = h^e - g^o - cofactor of x‚ÇÄ
        const d = Math.pow(h, e) - Math.pow(g, o);

        // Compute gcd(k(g,h), d(g,h))
        const gcdValue = gcd(k, d);

        // Derive x‚ÇÄ and q from cycle element identity
        const x0 = Math.round(k / gcdValue);
        const q = Math.round(d / gcdValue);

        // Update display
        document.getElementById('output-o').textContent = o.toString();
        document.getElementById('output-e').textContent = e.toString();
        document.getElementById('output-q').textContent = q.toString();
        document.getElementById('output-x0').textContent = x0.toString();

        // Update x-cycle display
        displayXCycle();
      } catch (err) {
        console.error('Error deriving parameters:', err);
      }
    }

    // Listen for changes to p, g, h
    document.getElementById('input-p').addEventListener('input', () => {
      updateBinaryDisplay();
      updateDerivedParameters();
      updateURLParams();
    });

    document.getElementById('input-g').addEventListener('input', () => {
      updateDerivedParameters();
      updateURLParams();
    });

    document.getElementById('input-h').addEventListener('input', () => {
      updateDerivedParameters();
      updateURLParams();
    });

    // Stop cycle animation when input fields receive focus
    document.getElementById('input-p').addEventListener('focus', stopCycle);
    document.getElementById('input-g').addEventListener('focus', stopCycle);
    document.getElementById('input-h').addEventListener('focus', stopCycle);

    // Configuration
    document.getElementById('init-btn').addEventListener('click', () => {
      const g = parseInt(document.getElementById('input-g').value);
      const h = parseInt(document.getElementById('input-h').value);
      const o = parseInt(document.getElementById('output-o').textContent);
      const e = parseInt(document.getElementById('output-e').textContent);
      const q = parseInt(document.getElementById('output-q').textContent);
      const x0 = parseInt(document.getElementById('output-x0').textContent);

      try {
        app.initialize(o, e, g, h, q, x0);
        document.getElementById('validation-message').innerHTML =
          '<div class="success-message">‚úì Board initialized successfully!</div>';
        setTimeout(() => {
          document.getElementById('validation-message').innerHTML = '';
        }, 3000);

        // Display x-cycle after successful initialization
        displayXCycle();
      } catch (err) {
        document.getElementById('validation-message').innerHTML =
          `<div class="validation-error">‚úó ${err.message}</div>`;
      }
    });


    // Canvas interaction
    const canvas = document.getElementById('board-canvas');

    canvas.addEventListener('click', (e) => {
      if (!app.renderer) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const cell = app.renderer.pixelToGrid(x, y);
      if (cell) {
        app.selectedCell = cell;
        app.renderer.selectedCell = cell;
        app.render();
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!app.renderer) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const cell = app.renderer.pixelToGrid(x, y);
      app.renderer.hoveredCell = cell;
      app.render();
    });

    canvas.addEventListener('mouseleave', () => {
      if (!app.renderer) return;
      app.renderer.hoveredCell = null;
      app.render();
    });

    // Control buttons
    document.getElementById('undo-btn').addEventListener('click', () => app.undo());
    document.getElementById('redo-btn').addEventListener('click', () => app.redo());
    document.getElementById('reset-btn').addEventListener('click', () => app.reset());

    // Conservation law buttons
    document.getElementById('g-right-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));

      app.showInputModal(
        '√óg Right ‚Üí',
        `Move how many pebbles to the right? (creates ${app.board.g} pebbles per pebble moved)`,
        count,
        (num) => {
          const success = app.applyAction(laws => laws.applyGMultiplyRight(j, i, num));
          if (success) {
            app.selectedCell = { j: j + 1, i: i };
            app.renderer.selectedCell = app.selectedCell;
            app.render();
          }
        }
      );
    });

    document.getElementById('g-left-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));
      const maxSets = Math.floor(count / app.board.g);

      const spreadMode = document.getElementById('spread-mode').checked;

      if (spreadMode && maxSets > 0) {
        // In spread mode, automatically use max without prompting
        const success = app.applyAction(laws => laws.applyGMultiplyLeft(j - 1, i, maxSets));
        if (success) {
          app.selectedCell = { j: j - 1, i: i };
          app.renderer.selectedCell = app.selectedCell;
          app.render();

          // Repeat if possible
          setTimeout(() => {
            const newCount = Math.abs(app.board.get(j - 1, i));
            const newMaxSets = Math.floor(newCount / app.board.g);
            if (newMaxSets > 0) {
              document.getElementById('g-left-btn').click();
            }
          }, 100);
        }
      } else {
        // Normal mode - show prompt
        app.showInputModal(
          '‚Üê √óg Left',
          `Combine how many sets of ${app.board.g} pebbles into 1? (max: ${maxSets})`,
          maxSets,
          (num) => {
            const success = app.applyAction(laws => laws.applyGMultiplyLeft(j - 1, i, num));
            if (success) {
              app.selectedCell = { j: j - 1, i: i };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          },
          maxSets
        );
      }
    });

    document.getElementById('h-down-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));

      app.showInputModal(
        '√óh Down ‚Üì',
        `Move how many pebbles down? (creates ${app.board.h} pebbles in square below)`,
        count,
        (num) => {
          const success = app.applyAction(laws => laws.applyHMultiplyDown(j, i, num));
          if (success) {
            app.selectedCell = { j: j, i: i - 1 };
            app.renderer.selectedCell = app.selectedCell;
            app.render();
          }
        }
      );
    });

    document.getElementById('h-up-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));
      const maxSets = Math.floor(count / app.board.h);

      const spreadMode = document.getElementById('spread-mode').checked;

      if (spreadMode && maxSets > 0) {
        // In spread mode, automatically use max without prompting
        const success = app.applyAction(laws => laws.applyHMultiplyUp(j, i, maxSets));
        if (success) {
          app.selectedCell = { j: j, i: i + 1 };
          app.renderer.selectedCell = app.selectedCell;
          app.render();

          // Repeat if possible
          setTimeout(() => {
            const newCount = Math.abs(app.board.get(j, i + 1));
            const newMaxSets = Math.floor(newCount / app.board.h);
            if (newMaxSets > 0) {
              document.getElementById('h-up-btn').click();
            }
          }, 100);
        }
      } else {
        // Normal mode - show prompt
        app.showInputModal(
          '‚Üë √óh Up',
          `Combine how many sets of ${app.board.h} pebbles into square above? (max: ${maxSets})`,
          maxSets,
          (num) => {
            const success = app.applyAction(laws => laws.applyHMultiplyUp(j, i, num));
            if (success) {
              app.selectedCell = { j: j, i: i + 1 };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          },
          maxSets
        );
      }
    });

    document.getElementById('special-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));
      const specialType = app.laws.getSpecialSystemType();

      if (specialType === '3x+1') {
        app.showInputModal(
          'Basis Law (3x+1)',
          `Apply 3x+1 law: moves pebble from (j=${j},i=${i}) to (j=${j+1},i=${i+2}) and adds opposite at (j=${j+1},i=${i}). How many pebbles?`,
          count,
          (num) => {
            const success = app.applyAction(laws => laws.applySpecial(j, i, num));
            if (success) {
              app.selectedCell = { j: j + 1, i: i + 2 };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
        );
      } else if (specialType === '5x+1') {
        app.showInputModal(
          'Basis Law (5x+1)',
          `Apply 5x+1 law: moves pebble from (j=${j},i=${i}) to (j=${j+1},i=${i+2}) and (j=${j+1},i=${i+1}), adds opposite at (j=${j+1},i=${i}). How many pebbles?`,
          count,
          (num) => {
            const success = app.applyAction(laws => laws.applySpecial(j, i, num));
            if (success) {
              app.selectedCell = { j: j + 1, i: i + 2 };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
        );
      }
    });

    document.getElementById('reverse-special-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));
      const specialType = app.laws.getSpecialSystemType();

      if (specialType === '3x+1') {
        app.showInputModal(
          'Reverse Basis Law (3x+1)',
          `Apply h¬≤ = g + 1: splits 1 pebble from (j=${j},i=${i}) into g at (j=${j-1},i=${i}), -h at (j=${j},i=${i-1}), and 1 at (j=${j},i=${i-2}). How many pebbles?`,
          count,
          (num) => {
            const success = app.applyAction(laws => laws.applyReverseSpecial(j, i, num));
            if (success) {
              app.selectedCell = { j: j - 1, i: i };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
        );
      } else if (specialType === '5x+1') {
        app.showInputModal(
          'Reverse Basis Law (5x+1)',
          `Apply h¬≤ = g - h + 1: splits 1 pebble from (j=${j},i=${i}) into g at (j=${j-1},i=${i}), -h at (j=${j},i=${i-1}), and 1 at (j=${j},i=${i-2}). How many pebbles?`,
          count,
          (num) => {
            const success = app.applyAction(laws => laws.applyReverseSpecial(j, i, num));
            if (success) {
              app.selectedCell = { j: j - 1, i: i };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
        );
      }
    });

    // Persistence buttons
    document.getElementById('copy-url-btn').addEventListener('click', () => persistence.copyURL());
    document.getElementById('save-local-btn').addEventListener('click', () => persistence.saveToLocalStorage());
    document.getElementById('load-local-btn').addEventListener('click', () => persistence.loadFromLocalStorage());
    document.getElementById('export-json-btn').addEventListener('click', () => persistence.exportJSON());
    document.getElementById('import-json-btn').addEventListener('click', () => {
      document.getElementById('json-file-input').click();
    });

    document.getElementById('json-file-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        persistence.importJSON(file).then(() => {
          alert('‚úì Configuration imported successfully!');
        }).catch(err => {
          alert(`‚úó Failed to import: ${err.message}`);
        });
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Don't trigger shortcuts when typing in input fields
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
      }

      // Undo/Redo
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          app.undo();
        } else if (e.key === 'z' && e.shiftKey || e.key === 'y') {
          e.preventDefault();
          app.redo();
        }
        return;
      }

      // Conservation law shortcuts (l, r, u, d, f, b)
      if (!app.selectedCell) return;

      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));
      const numPebbles = e.shiftKey ? count : 1; // Shift = max, no shift = 1

      switch(e.key.toLowerCase()) {
        case 'l': // Left
          e.preventDefault();
          const maxLeft = Math.floor(count / app.board.g);
          if (maxLeft > 0) {
            const numLeft = e.shiftKey ? maxLeft : 1;
            const success = app.applyAction(laws => laws.applyGMultiplyLeft(j - 1, i, numLeft));
            if (success) {
              app.selectedCell = { j: j - 1, i: i };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'r': // Right
          e.preventDefault();
          if (count > 0) {
            const success = app.applyAction(laws => laws.applyGMultiplyRight(j, i, numPebbles));
            if (success) {
              app.selectedCell = { j: j + 1, i: i };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'u': // Up
          e.preventDefault();
          const maxUp = Math.floor(count / app.board.h);
          if (maxUp > 0) {
            const numUp = e.shiftKey ? maxUp : 1;
            const success = app.applyAction(laws => laws.applyHMultiplyUp(j, i, numUp));
            if (success) {
              app.selectedCell = { j: j, i: i + 1 };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'd': // Down
          e.preventDefault();
          if (count > 0) {
            const success = app.applyAction(laws => laws.applyHMultiplyDown(j, i, numPebbles));
            if (success) {
              app.selectedCell = { j: j, i: i - 1 };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'f': // Forward (Basis Law)
          e.preventDefault();
          if (count > 0 && (app.laws.is3x1System() || app.laws.is5x1System())) {
            const success = app.applyAction(laws => laws.applySpecial(j, i, numPebbles));
            if (success) {
              app.selectedCell = { j: j + 1, i: i + 2 };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'b': // Backward (Reverse Basis Law)
          e.preventDefault();
          if (count > 0 && (app.laws.is3x1System() || app.laws.is5x1System())) {
            const success = app.applyAction(laws => laws.applyReverseSpecial(j, i, numPebbles));
            if (success) {
              app.selectedCell = { j: j - 1, i: i - 2 };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;
      }
    });

    // Load from URL or initialize default
    window.addEventListener('load', () => {
      // Check for query parameters p, g, h
      const urlParams = new URLSearchParams(window.location.search);
      const pParam = urlParams.get('p');
      const gParam = urlParams.get('g');
      const hParam = urlParams.get('h');

      // Set input fields from query parameters if present
      let hasQueryParams = false;
      if (pParam !== null) {
        document.getElementById('input-p').value = pParam;
        hasQueryParams = true;
      }
      if (gParam !== null) {
        document.getElementById('input-g').value = gParam;
        hasQueryParams = true;
      }
      if (hParam !== null) {
        document.getElementById('input-h').value = hParam;
        hasQueryParams = true;
      }

      // Initialize derived parameters with default or query param values
      updateBinaryDisplay();
      updateDerivedParameters();

      // Check for state parameter (takes precedence over query params)
      if (!persistence.loadFromURL()) {
        // Initialize board with current values (query params or defaults)
        document.getElementById('init-btn').click();
      }

      // Scroll to board after initialization
      setTimeout(() => {
        const boardContainer = document.getElementById('board-container');
        if (boardContainer) {
          boardContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }, 100);

      // Add event listeners for cycle navigation buttons
      document.getElementById('prev-btn').addEventListener('click', goToPrevP);
      document.getElementById('next-btn').addEventListener('click', goToNextP);
      document.getElementById('cycle-btn').addEventListener('click', toggleCycle);
    });
  </script>
</body>
</html>
