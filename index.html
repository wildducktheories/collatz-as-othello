<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Othello Board Collatz Cycle Explorer</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f5f5f5;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 8px 8px 0 0;
    }

    h1 {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    header p {
      font-size: 14px;
      opacity: 0.95;
    }

    .panel {
      padding: 25px;
      border-bottom: 1px solid #e0e0e0;
    }

    .panel:last-child {
      border-bottom: none;
      border-radius: 0 0 8px 8px;
    }

    .panel h2 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      color: #333;
    }

    .panel h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 10px;
      color: #555;
    }

    .config-panel {
      background: #fafafa;
    }

    .input-group {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }

    .input-field {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .input-field label {
      font-size: 13px;
      font-weight: 500;
      color: #555;
    }

    .input-field input {
      width: 100px;
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .input-field input:focus {
      outline: none;
      border-color: #667eea;
    }

    .output-field {
      width: 100px;
      padding: 8px 10px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background: #f5f5f5;
      font-size: 14px;
      color: #333;
      font-family: 'Courier New', Courier, monospace;
    }

    .output-field-binary {
      min-width: 200px;
      max-width: 400px;
      padding: 8px 10px;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background: #f5f5f5;
      font-size: 12px;
      color: #333;
      font-family: 'Courier New', Courier, monospace;
      word-break: break-all;
      overflow-wrap: break-word;
    }

    button {
      padding: 10px 18px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: #667eea;
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: #5568d3;
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: #e0e0e0;
      color: #333;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #d0d0d0;
    }

    .btn-danger {
      background: #ef4444;
      color: white;
    }

    .btn-danger:hover:not(:disabled) {
      background: #dc2626;
    }

    .canvas-container {
      display: flex;
      justify-content: center;
      padding: 30px;
      overflow: auto;
      background: #fafafa;
      min-height: 400px;
    }

    #board-canvas {
      border: 2px solid #ddd;
      border-radius: 4px;
      background: white;
      cursor: pointer;
    }

    .polynomial-display {
      font-family: 'Courier New', Courier, monospace;
      font-size: 16px;
      padding: 15px;
      background: #f9f9f9;
      border-radius: 4px;
      overflow-x: auto;
      border: 1px solid #e0e0e0;
      min-height: 50px;
    }

    .control-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .conservation-laws {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
    }

    .law-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .selected-info {
      padding: 12px;
      background: #fff9db;
      border-radius: 4px;
      margin-bottom: 15px;
      border-left: 4px solid #fbbf24;
      font-size: 14px;
    }

    .validation-error {
      color: #dc2626;
      margin-top: 10px;
      padding: 10px;
      background: #fee;
      border-radius: 4px;
      font-size: 13px;
    }

    #validation-message {
      min-height: 50px;
      margin: 10px 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .success-message {
      color: #059669;
      padding: 10px;
      background: #d1fae5;
      border-radius: 4px;
      font-size: 13px;
    }

    .status-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      margin-top: 10px;
    }

    .status-active {
      background: #dbeafe;
      color: #1e40af;
    }

    .status-zero {
      background: #d1fae5;
      color: #065f46;
    }

    label {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    input[type="checkbox"] {
      cursor: pointer;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      padding: 25px;
      border-radius: 8px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    }

    .modal-content h3 {
      margin-bottom: 15px;
      color: #333;
    }

    .modal-content input {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      margin: 10px 0;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      justify-content: flex-end;
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }

      .input-group {
        flex-direction: column;
      }

      .input-field input {
        width: 100%;
      }

      .control-grid {
        grid-template-columns: 1fr;
      }

      header {
        padding: 20px;
      }

      h1 {
        font-size: 22px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Othello Board Collatz Cycle Explorer</h1>
      <p>Interactive visualization of Collatz-type cycles using the Othello board analogy.
      <br>üéÆ <a href="https://wildducktheories.github.io/collatz-as-othello/" target="_blank" style="color: #ffffff; text-decoration: underline;">Latest Version</a> |
      üì¶ <a href="https://github.com/wildducktheories/collatz-as-othello/" target="_blank" style="color: #ffffff; text-decoration: underline;">Source Code</a> |
      üìÑ <a href="https://drive.google.com/file/d/1jdISz5k3N2xCxASek1AGC6UGJeYRF0V1/view" target="_blank" style="color: #ffffff; text-decoration: underline;">Paper</a> |
      üí¨ <a href="https://www.reddit.com/r/Collatz/comments/1pj1hjv/announcing_the_interactive_collatz_othello_board/" target="_blank" style="color: #ffffff; text-decoration: underline;">Discussion</a></p>
    </header>

    <div class="config-panel panel">
      <h2>Configuration</h2>
      <div class="input-group">
        <div class="input-field">
          <label>p (path):</label>
          <input type="text" id="input-p" value="1093">
        </div>
        <div class="input-field">
          <label>g (multiplier):</label>
          <input type="number" id="input-g" value="3" min="2">
        </div>
        <div class="input-field">
          <label>h (divisor):</label>
          <input type="number" id="input-h" value="2" min="2">
        </div>
      </div>

      <h3 style="font-size: 14px; font-weight: 600; margin: 15px 0 8px 0; color: #555;">Identifier</h3>
      <div class="input-group">
        <div class="input-field">
          <label>p:</label>
          <a href="#" id="output-p" style="color: #0066cc; cursor: pointer;">1093</a>
        </div>
        <div class="input-field">
          <label>b:</label>
          <a href="#" id="output-b" style="color: #0066cc; cursor: pointer;">0b10001000101</a>
        </div>
        <div class="input-field">
          <label>oe:</label>
          <a href="#" id="output-oe" style="color: #0066cc; cursor: pointer;">OEEOEEEO</a>
        </div>
      </div>

      <div class="input-group">
        <div class="input-field">
          <label>o (multipler steps):</label>
          <span id="output-o">3</span>
        </div>
        <div class="input-field">
          <label>e (divisor steps):</label>
          <span id="output-e">7</span>
        </div>
        <div class="input-field">
          <label>q (quotient):</label>
          <span id="output-q">1</span>
        </div>
        <div class="input-field">
          <label>x‚ÇÄ (cycle start):</label>
          <span id="output-x0">17</span>
        </div>
      </div>
      <div class="input-group">
        <button class="btn-primary" id="init-btn">Initialize Board</button>
      </div>
      <div style="margin-top: 15px;">
        <h3 style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #555;">Examples:</h3>
        <div style="font-size: 13px; line-height: 1.8; color: #666;">
          <strong>g=3, h=2:</strong>
          <a href="?p=9&g=3&h=2">p=9</a>,
          <a href="?p=17&g=3&h=2">p=17</a>,
          <a href="?p=33&g=3&h=2">p=33</a>,
          <a href="?p=65&g=3&h=2">p=65</a>,
          <a href="?p=37&g=3&h=2">p=37</a>,
          <a href="?p=73&g=3&h=2">p=73</a>,
          <a href="?p=585&g=3&h=2">p=585</a>,
          <a href="?p=281&g=3&h=2">p=281</a>,
          <a href="?p=293&g=3&h=2">p=293</a>,
          <a href="?p=2119&g=3&h=2">p=2119</a>,
          <a href="?p=4681&g=3&h=2">p=4681</a>,
          <a href="?p=8301&g=3&h=2">p=8301</a>
          <br>
          <strong>g=5, h=2:</strong>
          <a href="?p=9&g=5&h=2">p=9</a>,
          <a href="?p=17&g=5&h=2">p=17</a>,
          <a href="?p=33&g=5&h=2">p=33</a>,
          <a href="?p=65&g=5&h=2">p=65</a>,
          <a href="?p=133&g=5&h=2">p=133</a>,
          <a href="?p=1045&g=5&h=2">p=1045</a>,
          <a href="?p=1093&g=5&h=2">p=1093</a>
          <br>
          <strong>g=7, h=2:</strong>
          <a href="?p=9&g=7&h=2">p=9</a>,
          <a href="?p=17&g=7&h=2">p=17</a>,
          <a href="?p=33&g=7&h=2">p=33</a>,
          <a href="?p=65&g=7&h=2">p=65</a>
          <br>
          <strong>g=181, h=2:</strong>
          <a href="?p=131089&g=181&h=2">p=131089</a>,
          <a href="?p=131201&g=181&h=2">p=131201</a>
          <br>
          <strong>g=8, h=3:</strong>
          <a href="?p=585&g=8&h=3">p=585</a>
        </div>
      </div>
    </div>

    <div class="canvas-container" id="board-container">
      <canvas id="board-canvas"></canvas>
    </div>

    <div class="selected-info" id="selected-info">
      No cell selected. Click a cell on the board to select it.
    </div>

    <div id="validation-message"></div>

    <div class="panel">
      <h2>Cycle Controls</h2>
      <div id="x-cycle-display" style="font-size: 14px; color: #333; margin-bottom: 10px;">Computing x-cycle...</div>
      <div class="control-grid">
        <button class="btn-secondary" id="prev-btn">‚Üê Prev</button>
        <button class="btn-secondary" id="next-btn">Next ‚Üí</button>
        <button class="btn-secondary" id="cycle-btn">Cycle</button>
      </div>
      <div style="margin-top: 10px; font-size: 12px; color: #666; line-height: 1.6;">
        <strong>Usage:</strong> Navigate between x-cycle elements using Prev/Next. The Cycle button rotates through p-cycle members.
      </div>
    </div>

    <div class="panel">
      <h2>Conservation Law Controls</h2>

      <details style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px; cursor: pointer;">
        <summary style="font-weight: 600; color: #007bff; user-select: none; outline: none;">
          ‚ÑπÔ∏è Learn More: Force Conservation Analogy
        </summary>
        <div style="margin-top: 12px; padding: 12px; background: white; border-left: 3px solid #007bff; font-size: 12px; line-height: 1.7;">
          <div style="color: #555;">
            The board can be considered to be suffused with an <strong>electric field</strong> whose strength at position <span class="force-field"></span>.
            Each pebble carries a unit charge: <strong style="color: #000;">white = +1</strong>, <strong>black = -1</strong>.
            The net charge at square <span class="force-charge"></span> (positive, negative, or zero).
          </div>
          <div style="margin-top: 8px; color: #555;">
            The <strong>electric force</strong> at each square equals charge √ó field strength = <span class="force-at-square"></span>.
            Across the entire board, the <strong>net force is always zero</strong>:
          </div>
          <div id="force-conservation-eq" style="margin: 12px 0; padding: 10px; background: #f8f9fa; border-radius: 4px; text-align: center;">
          </div>
          <div style="color: #555;">
            All operations preserve this <strong>force conservation</strong> ‚Äî they rearrange charges without changing the net force.
          </div>
        </div>
      </details>

      <div class="conservation-laws">
        <div class="law-row">
          <button class="btn-primary" id="g-left-btn" disabled>‚Üê √óg Left (l)</button>
          <button class="btn-primary" id="g-right-btn" disabled>√óg Right ‚Üí (r)</button>
        </div>
        <div class="law-row">
          <button class="btn-primary" id="h-up-btn" disabled>‚Üë √óh Up (u)</button>
          <button class="btn-primary" id="h-down-btn" disabled>√óh Down ‚Üì (d)</button>
        </div>
        <div class="law-row">
          <button class="btn-primary" id="special-btn" disabled>Basis Law (f)</button>
          <button class="btn-primary" id="reverse-special-btn" disabled>Reverse Basis Law (b)</button>
        </div>
        <div class="law-row">
          <button class="btn-primary" id="reset-k-btn" title="Clear board to show only x‚ÇÄ¬∑d(g,h) part. Use 'q' shortcut to reconstruct q¬∑k(g,h) part of the identity q¬∑k(g,h) - x‚ÇÄ¬∑d(g,h) = 0">Reset q¬∑k (v)</button>
          <button class="btn-primary" id="random-btn">üé≤ Random (r)</button>
          <button class="btn-primary" id="local-minimiser-btn">üìâ Local Minimiser (m)</button>
        </div>
      </div>
      <div style="font-size: 12px; margin-top: 8px; color: #666; line-height: 1.6;">
        <strong>Keyboard shortcuts:</strong> Keys apply operations with 1 pebble. Hold <strong>Shift</strong> to use maximum available pebbles.
      </div>

      <div style="margin-top: 10px; font-size: 12px; color: #666; line-height: 1.6;">
        <strong>Spread mode:</strong> Automatically repeats Left/Up operations to reduce multiples to singletons.
      </div>
      <label style="margin-top: 10px; display: block;"><input type="checkbox" id="spread-mode"> Spread Mode</label>
    </div>

    <div class="panel">
      <h2>History Controls</h2>
      <div class="control-grid">
        <button class="btn-secondary" id="undo-btn" disabled>‚ü≤ Undo</button>
        <button class="btn-secondary" id="redo-btn" disabled>‚ü≥ Redo</button>
        <button class="btn-secondary" id="reset-btn" disabled>Reset</button>
        <button class="btn-secondary" id="animate-btn" disabled>‚ñ∂ Animate</button>
      </div>
      <div style="margin-top: 10px; font-size: 12px; color: #666; line-height: 1.6;">
        <strong>Usage:</strong> Use <strong>Undo/Redo</strong> to navigate changes, <strong>Reset</strong> to return to initial state, <strong>Animate</strong> to replay history step-by-step.
      </div>
    </div>

    <div class="panel">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h2 style="margin: 0;">Action Statistics</h2>
        <button class="btn-secondary" id="popout-stats-btn" title="Pop out to separate window (exit fullscreen first)" style="font-size: 16px; padding: 4px 8px; min-width: 32px;">‚ßâ</button>
      </div>
      <canvas id="action-stats-canvas" width="700" height="300" style="border: 1px solid #ddd; border-radius: 4px; background: white;"></canvas>
      <div id="action-stats-legend" style="margin-top: 10px; font-size: 12px; display: flex; flex-wrap: wrap; gap: 15px;"></div>
      <div id="action-stats-summary" style="margin-top: 10px; font-size: 13px; color: #666;"></div>
    </div>

    <div class="panel">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h2 style="margin: 0;">Entropy & Force Analysis</h2>
        <button class="btn-secondary" id="popout-entropy-btn" title="Pop out to separate window (exit fullscreen first)" style="font-size: 16px; padding: 4px 8px; min-width: 32px;">‚ßâ</button>
      </div>
      <canvas id="entropy-canvas" width="700" height="300" style="border: 1px solid #ddd; border-radius: 4px; background: white;"></canvas>
      <div id="entropy-legend" style="margin-top: 10px; font-size: 12px; display: flex; flex-wrap: wrap; gap: 15px;"></div>
      <div id="entropy-summary" style="margin-top: 10px; font-size: 13px; color: #666;"></div>
    </div>

    <div class="polynomial-panel panel">
      <h2>Polynomial Representation</h2>
      <div id="polynomial-identity" style="margin-bottom: 15px; font-size: 16px; font-weight: 600; color: #555;"></div>
      <div class="polynomial-display" id="polynomial-display">
        No board initialized. Click "Initialize Board" above to start.
      </div>
      <div id="polynomial-status"></div>

      <div style="margin-top: 20px;">
        <div id="k-heading" style="margin-bottom: 15px; font-size: 16px; color: #555;"></div>
        <div class="polynomial-display" id="k-polynomial-display" style="font-size: 14px;">
        </div>
      </div>

      <div style="margin-top: 15px;">
        <div id="d-heading" style="margin-bottom: 15px; font-size: 16px; color: #555;"></div>
        <div class="polynomial-display" id="d-polynomial-display" style="font-size: 14px;">
        </div>
      </div>

      <div style="margin-top: 15px;" id="basis-law-section">
        <div id="basis-law-heading" style="margin-bottom: 15px; font-size: 16px; color: #555;"></div>
        <div class="polynomial-display" id="basis-law-display" style="font-size: 14px;">
        </div>
      </div>

      <div style="margin-top: 15px;">
        <div id="force-heading" style="margin-bottom: 15px; font-size: 16px; color: #555;">Force Balance Equation:</div>
        <div class="polynomial-display" id="force-display" style="font-size: 14px;">
        </div>
      </div>
    </div>

    <div class="persistence-panel panel">
      <h2>Save & Share</h2>
      <div class="control-grid">
        <button class="btn-secondary" id="copy-url-btn" disabled>üìã Copy URL</button>
        <button class="btn-secondary" id="save-local-btn" disabled>üíæ Save to Browser</button>
        <button class="btn-secondary" id="load-local-btn">üìÅ Load from Browser</button>
        <button class="btn-secondary" id="export-json-btn" disabled>‚¨á Export JSON</button>
        <button class="btn-secondary" id="import-json-btn">‚¨Ü Import JSON</button>
      </div>
      <input type="file" id="json-file-input" accept=".json" style="display: none;">
    </div>
  </div>

  <!-- Modal for numeric input -->
  <div id="input-modal" class="modal">
    <div class="modal-content">
      <h3 id="modal-title">Enter value</h3>
      <p id="modal-description"></p>
      <input type="number" id="modal-input" min="1" value="1">
      <div class="modal-buttons">
        <button class="btn-secondary" id="modal-cancel">Cancel</button>
        <button class="btn-primary" id="modal-confirm">Apply</button>
      </div>
    </div>
  </div>

  <script>
    'use strict';

    // ========== BoardState Class ==========
    class BoardState {
      constructor(o, e, g, h, q, x0, p = null) {
        this.o = o;
        this.e = e;
        this.g = g;
        this.h = h;
        this.q = q;
        this.x0 = x0;
        this.p = p;
        this.grid = new Map();
        this.minCol = -1;
        this.maxCol = o - 1;
        this.minRow = 0;
        this.maxRow = e;
      }

      get(j, i) {
        const key = `${j},${i}`;
        return this.grid.get(key) || 0;
      }

      set(j, i, count) {
        const key = `${j},${i}`;
        if (count === 0) {
          this.grid.delete(key);
        } else {
          this.grid.set(key, count);
        }
      }

      add(j, i, count) {
        this.set(j, i, this.get(j, i) + count);
      }

      clone() {
        const newBoard = new BoardState(this.o, this.e, this.g, this.h, this.q, this.x0);
        newBoard.grid = new Map(this.grid);
        return newBoard;
      }

      isZeroState() {
        for (const [, count] of this.grid) {
          if (count !== 0) return false;
        }
        return true;
      }

      isEmpty() {
        return this.isZeroState();
      }

      // Calculate the polynomial sum: Œ£ c_{j,i} * g^{o-1-j} * h^i
      calculatePolynomialSum() {
        let sum = 0;
        for (const [key, count] of this.grid.entries()) {
          const [j, i] = key.split(',').map(Number);
          const gPower = this.o - 1 - j;
          const hPower = i;
          const term = count * Math.pow(this.g, gPower) * Math.pow(this.h, hPower);
          sum += term;
        }
        return sum;
      }

      calculateEntropy() {
        // Entropy formula: log_2(|c_{j,i}| + 1) + (1 if |c_{j,i}| > 0 else 0) + i + (o-1-j)*log_h(g)
        let totalEntropy = 0;
        const logHofG = Math.log(this.g) / Math.log(this.h);  // log_h(g) using change of base

        for (const [key, count] of this.grid.entries()) {
          const [j, i] = key.split(',').map(Number);
          const absCount = Math.abs(count);

          const entropy = Math.log2(absCount + 1) +
                         (absCount > 0 ? 1 : 0) +
                         i +
                         (this.o - 1 - j) * logHofG;

          totalEntropy += entropy;
        }
        return totalEntropy;
      }

      calculateWhiteForce() {
        // Sum of force experienced by white pebbles only
        // Force at (j,i) = c_{j,i} ¬∑ g^(o-1-j) ¬∑ h^i (only for c_{j,i} > 0)
        let whiteForce = 0;
        for (const [key, count] of this.grid.entries()) {
          if (count > 0) {  // Only white pebbles
            const [j, i] = key.split(',').map(Number);
            const gPower = this.o - 1 - j;
            const hPower = i;
            const force = count * Math.pow(this.g, gPower) * Math.pow(this.h, hPower);
            whiteForce += force;
          }
        }
        return whiteForce;
      }

      getPolynomial() {
        const terms = [];
        for (const [key, count] of this.grid) {
          const [j, i] = key.split(',').map(Number);
          const gPower = this.o - 1 - j;
          const hPower = i;
          terms.push({ coeff: count, gPower, hPower, j, i });
        }
        return terms.sort((a, b) => {
          if (b.gPower !== a.gPower) return b.gPower - a.gPower;
          return a.hPower - b.hPower;
        });
      }

      toJSON() {
        // Get current p value from input field
        const p = parseP(document.getElementById('input-p').value);
        const b = p > 0 ? '0b' + p.toString(2) : '';
        const oe = p > 0 ? toOENotation(p) : '';

        return {
          p: p,
          b: b,
          oe: oe,
          o: this.o,
          e: this.e,
          g: this.g,
          h: this.h,
          q: this.q,
          x0: this.x0,
          grid: Array.from(this.grid.entries())
        };
      }

      static fromJSON(json) {
        const board = new BoardState(json.o, json.e, json.g, json.h, json.q, json.x0, json.p || null);
        board.grid = new Map(json.grid);

        // Restore p value to input field if present
        if (json.p) {
          document.getElementById('input-p').value = json.p;
          updateBinaryDisplay();
        }

        return board;
      }
    }

    // ========== History Class ==========
    class History {
      constructor(initialState = null) {
        this.initialState = initialState;  // Starting BoardState for replay
        this.actions = [];                  // Array of action objects
        this.currentIndex = -1;             // -1 = at initialState, 0 = after actions[0], etc.
        this.maxSize = 10000;               // Maximum number of actions (increased for animation)
      }

      // Record a new action (branching: discards future actions if not at end)
      recordAction(action) {
        // Truncate any future actions (branching)
        this.actions = this.actions.slice(0, this.currentIndex + 1);

        // Add new action
        this.actions.push(action);

        // Enforce max size
        if (this.actions.length > this.maxSize) {
          this.actions.shift();
          // initialState becomes the state after first action (would need checkpoint)
        } else {
          this.currentIndex++;
        }
      }

      canUndo() {
        return this.currentIndex >= 0;
      }

      canRedo() {
        return this.currentIndex < this.actions.length - 1;
      }

      // Returns the action to undo (caller applies inverse or rebuilds from checkpoint)
      getUndoAction() {
        if (this.canUndo()) {
          const action = this.actions[this.currentIndex];
          this.currentIndex--;
          return action;
        }
        return null;
      }

      // Returns the action to redo (caller applies action)
      getRedoAction() {
        if (this.canRedo()) {
          this.currentIndex++;
          return this.actions[this.currentIndex];
        }
        return null;
      }

      // Get current state by replaying actions from initialState or nearest checkpoint
      getCurrentState() {
        if (this.currentIndex < 0) {
          return this.initialState ? this.initialState.clone() : null;
        }

        // Find the nearest checkpoint at or before currentIndex
        let checkpointIndex = -1;
        let checkpointState = this.initialState;

        for (let i = this.currentIndex; i >= 0; i--) {
          if (this.actions[i].type === 'checkpoint') {
            checkpointIndex = i;
            checkpointState = this.actions[i].state;
            break;
          }
        }

        // Replay from checkpoint to currentIndex
        let state = checkpointState ? checkpointState.clone() : null;
        if (!state) return null;

        for (let i = checkpointIndex + 1; i <= this.currentIndex; i++) {
          state = this.applyActionToState(state, this.actions[i]);
        }

        return state;
      }

      // Apply an action to a state (used for replay)
      applyActionToState(state, action) {
        if (action.type === 'checkpoint') {
          return action.state.clone();
        }

        // For regular actions, apply them to the state
        const laws = new ConservationLaws(state);

        switch (action.type) {
          case 'gRight':
            laws.applyGMultiplyRight(action.j, action.i, action.count);
            break;
          case 'gLeft':
            laws.applyGMultiplyLeft(action.j, action.i, action.count);
            break;
          case 'hUp':
            laws.applyHMultiplyUp(action.j, action.i, action.count);
            break;
          case 'hDown':
            laws.applyHMultiplyDown(action.j, action.i, action.count);
            break;
          case 'basisLaw':
            laws.applySpecial(action.j, action.i, action.count);
            break;
          case 'reverseBasisLaw':
            laws.applyReverseSpecial(action.j, action.i, action.count);
            break;
        }

        return state;
      }

      // Get inverse of an action (for efficient undo of reversible actions)
      getInverseAction(action) {
        const inverseMap = {
          'gRight': 'gLeft',
          'gLeft': 'gRight',
          'hUp': 'hDown',
          'hDown': 'hUp',
          'basisLaw': 'reverseBasisLaw',
          'reverseBasisLaw': 'basisLaw'
        };

        if (action.type === 'checkpoint') {
          return null; // Checkpoints don't have inverses
        }

        return {
          ...action,
          type: inverseMap[action.type]
        };
      }

      clear() {
        this.actions = [];
        this.currentIndex = -1;
      }

      setInitialState(state) {
        this.initialState = state ? state.clone() : null;
      }
    }

    // ========== Renderer Class ==========
    class Renderer {
      constructor(canvas, board) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.board = board;
        this.cellSize = 60;
        this.padding = 50;
        this.pebbleRadius = 8;
        this.maxPebblesPerCell = 10;
        this.selectedCell = null;
        this.hoveredCell = null;

        this.colors = {
          gridLine: '#cccccc',
          cellSelected: '#fff9db',
          cellHover: '#e0f2fe',
          whitePebble: '#ffffff',
          whitePebbleStroke: '#333333',
          blackPebble: '#1f2937',
          blackPebbleStroke: '#666666',
          text: '#333333'
        };
      }

      calculateDimensions() {
        const cols = this.board.maxCol - this.board.minCol + 1;
        const rows = this.board.maxRow - this.board.minRow + 1;
        return {
          width: cols * this.cellSize + 2 * this.padding,
          height: rows * this.cellSize + 2 * this.padding
        };
      }

      gridToPixel(j, i) {
        const x = this.padding + (j - this.board.minCol) * this.cellSize;
        const y = this.padding + (this.board.maxRow - i) * this.cellSize;
        return { x, y };
      }

      pixelToGrid(x, y) {
        const j = Math.floor((x - this.padding) / this.cellSize) + this.board.minCol;
        const i = this.board.maxRow - Math.floor((y - this.padding) / this.cellSize);

        if (j >= this.board.minCol && j <= this.board.maxCol &&
            i >= this.board.minRow && i <= this.board.maxRow) {
          return { j, i };
        }
        return null;
      }

      render() {
        const dims = this.calculateDimensions();
        if (this.canvas.width !== dims.width || this.canvas.height !== dims.height) {
          this.canvas.width = dims.width;
          this.canvas.height = dims.height;
        }

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        this.drawGrid();

        if (this.hoveredCell && (!this.selectedCell || this.hoveredCell.j !== this.selectedCell.j || this.hoveredCell.i !== this.selectedCell.i)) {
          this.highlightCell(this.hoveredCell.j, this.hoveredCell.i, this.colors.cellHover);
        }

        if (this.selectedCell) {
          this.highlightCell(this.selectedCell.j, this.selectedCell.i, this.colors.cellSelected);
        }

        for (let i = this.board.minRow; i <= this.board.maxRow; i++) {
          for (let j = this.board.minCol; j <= this.board.maxCol; j++) {
            const count = this.board.get(j, i);
            if (count !== 0) {
              this.drawPebbles(j, i, count);
            }
          }
        }

        this.drawLabels();
      }

      drawGrid() {
        this.ctx.strokeStyle = this.colors.gridLine;
        this.ctx.lineWidth = 1;

        const cols = this.board.maxCol - this.board.minCol + 1;
        const rows = this.board.maxRow - this.board.minRow + 1;

        for (let col = 0; col <= cols; col++) {
          const x = this.padding + col * this.cellSize;
          this.ctx.beginPath();
          this.ctx.moveTo(x, this.padding);
          this.ctx.lineTo(x, this.padding + rows * this.cellSize);
          this.ctx.stroke();
        }

        for (let row = 0; row <= rows; row++) {
          const y = this.padding + row * this.cellSize;
          this.ctx.beginPath();
          this.ctx.moveTo(this.padding, y);
          this.ctx.lineTo(this.padding + cols * this.cellSize, y);
          this.ctx.stroke();
        }
      }

      drawPebbles(j, i, count) {
        const { x, y } = this.gridToPixel(j, i);
        const centerX = x + this.cellSize / 2;
        const centerY = y + this.cellSize / 2;

        const isWhite = count > 0;
        const absCount = Math.abs(count);

        if (absCount <= this.maxPebblesPerCell) {
          this.drawPebblePattern(centerX, centerY, absCount, isWhite);
        } else {
          this.drawPebbleWithCount(centerX, centerY, count, isWhite);
        }
      }

      drawPebblePattern(centerX, centerY, count, isWhite) {
        const patterns = {
          1: [[0, 0]],
          2: [[-0.3, 0], [0.3, 0]],
          3: [[-0.3, -0.3], [0.3, -0.3], [0, 0.3]],
          4: [[-0.3, -0.3], [0.3, -0.3], [-0.3, 0.3], [0.3, 0.3]],
          5: [[-0.3, -0.3], [0.3, -0.3], [0, 0], [-0.3, 0.3], [0.3, 0.3]],
          6: [[-0.3, -0.3], [0, -0.3], [0.3, -0.3], [-0.3, 0.3], [0, 0.3], [0.3, 0.3]],
          7: [[-0.3, -0.3], [0, -0.3], [0.3, -0.3], [0, 0], [-0.3, 0.3], [0, 0.3], [0.3, 0.3]],
          8: [[-0.3, -0.3], [0, -0.3], [0.3, -0.3], [-0.3, 0], [0.3, 0], [-0.3, 0.3], [0, 0.3], [0.3, 0.3]],
          9: [[-0.3, -0.3], [0, -0.3], [0.3, -0.3], [-0.3, 0], [0, 0], [0.3, 0], [-0.3, 0.3], [0, 0.3], [0.3, 0.3]],
          10: [[-0.35, -0.35], [-0.12, -0.35], [0.12, -0.35], [0.35, -0.35], [-0.35, 0], [0.35, 0], [-0.35, 0.35], [-0.12, 0.35], [0.12, 0.35], [0.35, 0.35]]
        };

        const pattern = patterns[count] || patterns[1];
        const scale = this.cellSize * 0.3;

        pattern.forEach(([dx, dy]) => {
          const px = centerX + dx * scale;
          const py = centerY + dy * scale;
          this.drawSinglePebble(px, py, isWhite);
        });
      }

      drawSinglePebble(x, y, isWhite) {
        this.ctx.beginPath();
        this.ctx.arc(x, y, this.pebbleRadius, 0, 2 * Math.PI);

        if (isWhite) {
          this.ctx.fillStyle = this.colors.whitePebble;
          this.ctx.fill();
          this.ctx.strokeStyle = this.colors.whitePebbleStroke;
          this.ctx.lineWidth = 2;
          this.ctx.stroke();
        } else {
          this.ctx.fillStyle = this.colors.blackPebble;
          this.ctx.fill();
          this.ctx.strokeStyle = this.colors.blackPebbleStroke;
          this.ctx.lineWidth = 1;
          this.ctx.stroke();
        }
      }

      drawPebbleWithCount(x, y, count, isWhite) {
        const radius = this.cellSize * 0.35;

        this.ctx.beginPath();
        this.ctx.arc(x, y, radius, 0, 2 * Math.PI);

        if (isWhite) {
          this.ctx.fillStyle = this.colors.whitePebble;
          this.ctx.fill();
          this.ctx.strokeStyle = this.colors.whitePebbleStroke;
          this.ctx.lineWidth = 2;
          this.ctx.stroke();
          this.ctx.fillStyle = this.colors.text;
        } else {
          this.ctx.fillStyle = this.colors.blackPebble;
          this.ctx.fill();
          this.ctx.strokeStyle = this.colors.blackPebbleStroke;
          this.ctx.lineWidth = 1;
          this.ctx.stroke();
          this.ctx.fillStyle = this.colors.whitePebble;
        }

        this.ctx.font = 'bold 14px sans-serif';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(Math.abs(count).toString(), x, y);
      }

      highlightCell(j, i, color) {
        const { x, y } = this.gridToPixel(j, i);
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2);
      }

      drawLabels() {
        this.ctx.fillStyle = this.colors.text;
        this.ctx.font = '12px sans-serif';

        const cols = this.board.maxCol - this.board.minCol + 1;
        const rows = this.board.maxRow - this.board.minRow + 1;
        const gridBottom = this.padding + rows * this.cellSize;
        const gridMiddleX = this.padding + (cols * this.cellSize) / 2;
        const gridMiddleY = this.padding + (rows * this.cellSize) / 2;

        // Horizontal axis - column numbers at bottom
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'top';
        for (let j = this.board.minCol; j <= this.board.maxCol; j++) {
          const { x } = this.gridToPixel(j, 0);
          this.ctx.fillText(j.toString(), x + this.cellSize / 2, gridBottom + 5);
        }

        // "j" axis label at bottom center
        this.ctx.font = 'italic 14px sans-serif';
        this.ctx.fillText('j', gridMiddleX, gridBottom + 28);
        this.ctx.font = '12px sans-serif';

        // Vertical axis - row numbers on left
        this.ctx.textAlign = 'right';
        this.ctx.textBaseline = 'middle';
        for (let i = this.board.minRow; i <= this.board.maxRow; i++) {
          const { y } = this.gridToPixel(0, i);
          this.ctx.fillText(i.toString(), this.padding - 10, y + this.cellSize / 2);
        }

        // "i" axis label on left center
        this.ctx.textAlign = 'center';
        this.ctx.font = 'italic 14px sans-serif';
        this.ctx.fillText('i', this.padding / 3, gridMiddleY);
      }
    }

    // ========== ConservationLaws Class ==========
    class ConservationLaws {
      constructor(board) {
        this.board = board;
      }

      canApplyGMultiplyRight(j, i) {
        return j < this.board.maxCol && this.board.get(j, i) !== 0;
      }

      applyGMultiplyRight(j, i, numPebbles) {
        if (!this.canApplyGMultiplyRight(j, i)) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (numPebbles > absAvailable) return false;

        this.board.add(j, i, -sign * numPebbles);
        this.board.add(j + 1, i, sign * this.board.g * numPebbles);

        return true;
      }

      canApplyGMultiplyLeft(j, i) {
        if (j < this.board.minCol) return false;
        const count = this.board.get(j + 1, i);
        return Math.abs(count) >= this.board.g;
      }

      applyGMultiplyLeft(j, i, numSets) {
        if (!this.canApplyGMultiplyLeft(j, i)) return false;

        const count = this.board.get(j + 1, i);
        const sign = Math.sign(count);
        const maxSets = Math.floor(Math.abs(count) / this.board.g);

        if (numSets > maxSets) return false;

        this.board.add(j + 1, i, -sign * this.board.g * numSets);
        this.board.add(j, i, sign * numSets);

        return true;
      }

      canApplyHMultiplyDown(j, i) {
        return i > this.board.minRow && this.board.get(j, i) !== 0;
      }

      applyHMultiplyDown(j, i, numPebbles) {
        if (!this.canApplyHMultiplyDown(j, i)) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (numPebbles > absAvailable) return false;

        // Move DOWN: 1 pebble at (j, i) becomes h pebbles at (j, i-1)
        this.board.add(j, i, -sign * numPebbles);
        this.board.add(j, i - 1, sign * this.board.h * numPebbles);

        return true;
      }

      canApplyHMultiplyUp(j, i) {
        if (i >= this.board.maxRow) return false;
        const count = this.board.get(j, i);
        return Math.abs(count) >= this.board.h;
      }

      applyHMultiplyUp(j, i, numSets) {
        if (!this.canApplyHMultiplyUp(j, i)) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const maxSets = Math.floor(Math.abs(count) / this.board.h);

        if (numSets > maxSets) return false;

        // Move UP: h pebbles at (j, i) becomes 1 pebble at (j, i+1)
        this.board.add(j, i, -sign * this.board.h * numSets);
        this.board.add(j, i + 1, sign * numSets);

        return true;
      }

      // Generalized Basis Law: g = (g+1) in base h minus 1
      // Convert number to base h, returns array of digits [d_k, d_{k-1}, ..., d_1, d_0]
      toBaseH(num, base) {
        if (num === 0) return [0];
        const digits = [];
        while (num > 0) {
          digits.unshift(num % base);
          num = Math.floor(num / base);
        }
        return digits;
      }

      getBasisLawDescription() {
        const gPlus1 = this.board.g + 1;
        const digits = this.toBaseH(gPlus1, this.board.h);

        // Build the formula string
        let formula = '';
        for (let power = digits.length - 1; power >= 0; power--) {
          const digit = digits[power];
          if (digit > 0) {
            if (formula && power > 0) formula += ' + ';
            if (digit > 1) formula += digit + '¬∑';
            if (power > 1) formula += `h^${power}`;
            else if (power === 1) formula += 'h';
            else if (power === 0 && digit > 1) formula += '1';
          }
        }
        return `g = ${formula} - 1`;
      }

      // Legacy system type checks for backward compatibility
      is3x1System() {
        return this.board.g === this.board.h * this.board.h - 1;
      }

      is5x1System() {
        return this.board.g === this.board.h * this.board.h + this.board.h - 1;
      }

      getSpecialSystemType() {
        // Return the generalized description
        const gPlus1 = this.board.g + 1;
        const digits = this.toBaseH(gPlus1, this.board.h);
        const maxPower = digits.length - 1;

        // Check for classic systems
        if (this.is3x1System()) return '3x+1';
        if (this.is5x1System()) return '5x+1';

        // Return generalized description
        return `${this.board.g}x+1 (h^${maxPower} basis)`;
      }

      canApplySpecial(j, i) {
        if (this.board.get(j, i) === 0) return false;
        if (j >= this.board.maxCol) return false;

        // Find maximum power needed (highest power in base-h representation of g+1)
        const gPlus1 = this.board.g + 1;
        const digits = this.toBaseH(gPlus1, this.board.h);
        const maxPower = digits.length - 1;

        // Need room for i + maxPower
        return i + maxPower <= this.board.maxRow;
      }

      applySpecial3x1(j, i, numPebbles) {
        if (!this.is3x1System()) return false;
        if (j >= this.board.maxCol || i + 2 > this.board.maxRow) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (numPebbles > absAvailable) return false;

        // For 3x+1 (g = h¬≤ - 1):
        // Remove pebble from (j, i)
        // Add same color pebble at (j+1, i+2)
        // Add opposite color pebble at (j+1, i)
        this.board.add(j, i, -sign * numPebbles);
        this.board.add(j + 1, i + 2, sign * numPebbles);
        this.board.add(j + 1, i, -sign * numPebbles);

        return true;
      }

      applySpecial5x1(j, i, numPebbles) {
        if (!this.is5x1System()) return false;
        if (j >= this.board.maxCol || i + 2 > this.board.maxRow) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (numPebbles > absAvailable) return false;

        // For 5x+1 (g = h¬≤ + h - 1):
        // Remove pebble from (j, i)
        // Add same color pebbles at (j+1, i+2) and (j+1, i+1)
        // Add opposite color pebble at (j+1, i)
        this.board.add(j, i, -sign * numPebbles);
        this.board.add(j + 1, i + 2, sign * numPebbles);
        this.board.add(j + 1, i + 1, sign * numPebbles);
        this.board.add(j + 1, i, -sign * numPebbles);

        return true;
      }

      // Generalized Basis Law: g = (g+1)_h - 1
      applySpecialGeneralized(j, i, numPebbles) {
        if (!this.canApplySpecial(j, i)) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (numPebbles > absAvailable) return false;

        // Convert g+1 to base h
        const gPlus1 = this.board.g + 1;
        const digits = this.toBaseH(gPlus1, this.board.h);

        // Remove source pebble
        this.board.add(j, i, -sign * numPebbles);

        // Add pebbles according to base-h representation of (g+1)
        // For each power, add digit * pebbles at (j+1, i+power)
        for (let power = 0; power < digits.length; power++) {
          const digit = digits[digits.length - 1 - power]; // digits stored MSB first
          if (power === 0) {
            // At i+0: d_0 - 1 (the -1 from g = (g+1) - 1)
            if (digit > 0) {
              this.board.add(j + 1, i, sign * digit * numPebbles);
            }
            this.board.add(j + 1, i, -sign * numPebbles); // subtract 1
          } else if (digit > 0) {
            // At i+power: d_power pebbles
            this.board.add(j + 1, i + power, sign * digit * numPebbles);
          }
        }

        return true;
      }

      applySpecial(j, i, numPebbles) {
        // Use generalized version for all cases
        return this.applySpecialGeneralized(j, i, numPebbles);
      }

      // Reverse of applySpecial3x1: h¬≤ = g + 1
      // Using h^i = h^(i-2) ¬∑ (g + 1) = g¬∑h^(i-2) + h^(i-2)
      applyReverseSpecial3x1(j, i, numPebbles) {
        if (!this.is3x1System()) return false;
        if (j <= this.board.minCol || i < 2) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (sign === 0 || numPebbles > absAvailable) return false;

        // For 3x+1 (g = h¬≤ - 1), reverse means: h¬≤ = g + 1
        // g^(o-1-j)¬∑h^i = g^(o-j)¬∑h^(i-2) + g^(o-1-j)¬∑h^(i-2)
        this.board.add(j, i, -sign * numPebbles);          // remove from source
        this.board.add(j - 1, i - 2, sign * numPebbles);   // g¬∑h^(i-2) term
        this.board.add(j, i - 2, sign * numPebbles);       // h^(i-2) constant term

        return true;
      }

      // Reverse of applySpecial5x1: h¬≤ = g - h + 1
      // Using h^i = h^(i-2) ¬∑ (g - h + 1) = g¬∑h^(i-2) - h^(i-1) + h^(i-2)
      applyReverseSpecial5x1(j, i, numPebbles) {
        if (!this.is5x1System()) return false;
        if (j <= this.board.minCol || i < 2) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (sign === 0 || numPebbles > absAvailable) return false;

        // For 5x+1 (g = h¬≤ + h - 1), reverse means: h¬≤ = g - h + 1
        // g^(o-1-j)¬∑h^i = g^(o-j)¬∑h^(i-2) - g^(o-1-j)¬∑h^(i-1) + g^(o-1-j)¬∑h^(i-2)
        this.board.add(j, i, -sign * numPebbles);          // remove from source
        this.board.add(j - 1, i - 2, sign * numPebbles);   // g¬∑h^(i-2) term
        this.board.add(j, i - 1, -sign * numPebbles);      // -h^(i-1) term
        this.board.add(j, i - 2, sign * numPebbles);       // h^(i-2) constant term

        return true;
      }

      // Generalized Reverse Basis Law
      // If g+1 = sum(d_i * h^i), then h^k = g+1 - sum(d_i * h^i for i<k)
      // where k is the highest power
      applyReverseSpecialGeneralized(j, i, numPebbles) {
        if (!this.canApplyReverseSpecial(j, i)) return false;

        const count = this.board.get(j, i);
        const sign = Math.sign(count);
        const absAvailable = Math.abs(count);

        if (sign === 0 || numPebbles > absAvailable) return false;

        // Convert g+1 to base h
        const gPlus1 = this.board.g + 1;
        const digits = this.toBaseH(gPlus1, this.board.h);
        const maxPower = digits.length - 1;

        // h^i = h^(i-maxPower) * h^maxPower
        // h^maxPower = (g+1) - (lower power terms)
        // So h^i = h^(i-maxPower) * [(g+1) - (lower terms)]
        //        = h^(i-maxPower) * g + h^(i-maxPower) - (h^(i-maxPower) * lower terms)

        this.board.add(j, i, -sign * numPebbles); // remove from source

        // Add g * h^(i-maxPower) term at (j-1, i-maxPower)
        this.board.add(j - 1, i - maxPower, sign * numPebbles);

        // Add the +1 term: h^(i-maxPower) at (j, i-maxPower)
        this.board.add(j, i - maxPower, sign * numPebbles);

        // Subtract lower power terms
        for (let power = 0; power < maxPower; power++) {
          const digit = digits[digits.length - 1 - power];
          if (digit > 0) {
            this.board.add(j, i - maxPower + power, -sign * digit * numPebbles);
          }
        }

        return true;
      }

      applyReverseSpecial(j, i, numPebbles) {
        // Use generalized version for all cases
        return this.applyReverseSpecialGeneralized(j, i, numPebbles);
      }

      canApplyReverseSpecial(j, i) {
        if (j <= this.board.minCol) return false;

        const count = this.board.get(j, i);
        if (Math.sign(count) === 0) return false;

        // Need i >= maxPower
        const gPlus1 = this.board.g + 1;
        const digits = this.toBaseH(gPlus1, this.board.h);
        const maxPower = digits.length - 1;

        return i >= maxPower;
      }

      canResetK() {
        // Reset q¬∑k can be performed at any time
        return true;
      }

      applyResetK() {
        // Reset q¬∑k clears the board to show only the x‚ÇÄ¬∑d(g,h) part of the identity:
        // q¬∑k(g,h) - x‚ÇÄ¬∑d(g,h) = 0
        // Board shows: x‚ÇÄ¬∑g^o - x‚ÇÄ¬∑h^e (which equals -x‚ÇÄ¬∑d where d = h^e - g^o)
        // User can then reconstruct the q¬∑k(g,h) part using operations (esp. 'q' shortcut)

        const o = this.board.o;
        const e = this.board.e;
        const g = this.board.g;
        const h = this.board.h;
        const x0 = this.board.x0;

        // Clear the board first
        this.board.grid.clear();

        // Calculate d = h^e - g^o
        const d = Math.pow(h, e) - Math.pow(g, o);

        // Set the three positions:
        // (-1, 0): x‚ÇÄ white pebbles ‚Üí x‚ÇÄ¬∑g^o
        this.board.set(-1, 0, x0);

        // (o-1, e): x‚ÇÄ black pebbles ‚Üí -x‚ÇÄ¬∑h^e
        this.board.set(o - 1, e, -x0);

        // (o-1, 0): x‚ÇÄ¬∑d pebbles (sign depends on d)
        if (d !== 0) {
          this.board.set(o - 1, 0, x0 * d);
        }

        return true;
      }
    }

    // ========== Persistence Class ==========
    class Persistence {
      constructor(app) {
        this.app = app;
        this.storageKey = 'othello-collatz-boards';
      }

      generateURL() {
        const state = this.app.board.toJSON();
        const encoded = btoa(JSON.stringify(state));
        const url = new URL(window.location.href);
        url.searchParams.set('state', encoded);
        return url.toString();
      }

      loadFromURL() {
        const url = new URL(window.location.href);
        const encoded = url.searchParams.get('state');

        if (encoded) {
          try {
            const json = JSON.parse(atob(encoded));
            const board = BoardState.fromJSON(json);
            this.app.board = board;
            this.app.laws = new ConservationLaws(board);
            this.app.renderer.board = board;
            this.app.history.clear();
            this.app.history.push(board);
            this.app.initialBoard = board.clone();
            this.app.render();
            return true;
          } catch (e) {
            console.error('Failed to load state from URL:', e);
            return false;
          }
        }

        return false;
      }

      copyURL() {
        const url = this.generateURL();
        navigator.clipboard.writeText(url).then(() => {
          alert('‚úì URL copied to clipboard! Share this link to save your board configuration.');
        }).catch(err => {
          console.error('Failed to copy URL:', err);
          alert('Failed to copy URL. Please copy manually from the address bar.');
        });
      }

      saveToLocalStorage() {
        const name = prompt('Enter a name for this configuration:', `Config-${Date.now()}`);
        if (!name) return;

        const saved = this.getSavedBoards();
        saved[name] = {
          timestamp: Date.now(),
          version: 2,  // Bump version for action-based format
          currentState: this.app.board.toJSON(),
          history: {
            initialState: this.app.history.initialState ? this.app.history.initialState.toJSON() : null,
            actions: this.app.history.actions.map(action => {
              if (action.type === 'checkpoint') {
                return {
                  ...action,
                  state: action.state.toJSON()
                };
              }
              return action;
            }),
            currentIndex: this.app.history.currentIndex
          },
          initialBoard: this.app.initialBoard ? this.app.initialBoard.toJSON() : null
        };
        localStorage.setItem(this.storageKey, JSON.stringify(saved));
        alert(`‚úì Configuration saved as "${name}"`);
      }

      loadFromLocalStorage() {
        const saved = this.getSavedBoards();
        const names = Object.keys(saved);

        if (names.length === 0) {
          alert('No saved configurations found.');
          return;
        }

        const name = prompt(`Enter configuration name to load:\n\nAvailable: ${names.join(', ')}`);
        if (!name || !saved[name]) {
          alert('Configuration not found.');
          return;
        }

        const savedData = saved[name];

        // Support version 2 (actions), version 1 (states), and old format
        if (savedData.version === 2 && savedData.history && savedData.history.actions) {
          // Version 2: Action-based history
          const board = BoardState.fromJSON(savedData.currentState);
          this.app.board = board;
          this.app.laws = new ConservationLaws(board);
          this.app.renderer.board = board;

          // Restore action-based history
          this.app.history.clear();
          if (savedData.history.initialState) {
            this.app.history.initialState = BoardState.fromJSON(savedData.history.initialState);
          }
          this.app.history.actions = savedData.history.actions.map(action => {
            if (action.type === 'checkpoint') {
              return {
                ...action,
                state: BoardState.fromJSON(action.state)
              };
            }
            return action;
          });
          this.app.history.currentIndex = savedData.history.currentIndex;

          // Restore initial board
          if (savedData.initialBoard) {
            this.app.initialBoard = BoardState.fromJSON(savedData.initialBoard);
          } else {
            this.app.initialBoard = board.clone();
          }
        } else if (savedData.version === 1 && savedData.currentState) {
          // Version 1: State-based history (backward compatibility)
          const board = BoardState.fromJSON(savedData.currentState);
          this.app.board = board;
          this.app.laws = new ConservationLaws(board);
          this.app.renderer.board = board;
          this.app.history.clear();
          this.app.history.setInitialState(board);
          this.app.initialBoard = savedData.initialBoard ? BoardState.fromJSON(savedData.initialBoard) : board.clone();
        } else {
          // Very old format (just state, no version)
          const board = BoardState.fromJSON(savedData.state);
          this.app.board = board;
          this.app.laws = new ConservationLaws(board);
          this.app.renderer.board = board;
          this.app.history.clear();
          this.app.history.setInitialState(board);
          this.app.initialBoard = board.clone();
        }

        this.app.render();
      }

      getSavedBoards() {
        const saved = localStorage.getItem(this.storageKey);
        return saved ? JSON.parse(saved) : {};
      }

      exportJSON() {
        // Export current state plus full history (action-based)
        const exportData = {
          version: 2,  // Bump version for action-based format
          currentState: this.app.board.toJSON(),
          history: {
            initialState: this.app.history.initialState ? this.app.history.initialState.toJSON() : null,
            actions: this.app.history.actions.map(action => {
              if (action.type === 'checkpoint') {
                return {
                  ...action,
                  state: action.state.toJSON()
                };
              }
              return action;
            }),
            currentIndex: this.app.history.currentIndex
          },
          initialBoard: this.app.initialBoard ? this.app.initialBoard.toJSON() : null,
          exportTimestamp: new Date().toISOString()
        };

        const json = JSON.stringify(exportData, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `othello-collatz-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      importJSON(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();

          reader.onload = (e) => {
            try {
              const json = JSON.parse(e.target.result);

              // Support version 2 (actions), version 1 (states), and old format
              if (json.version === 2 && json.history && json.history.actions) {
                // Version 2: Action-based history
                const board = BoardState.fromJSON(json.currentState);
                this.app.board = board;
                this.app.laws = new ConservationLaws(board);
                this.app.renderer.board = board;

                // Restore action-based history
                this.app.history.clear();
                if (json.history.initialState) {
                  this.app.history.initialState = BoardState.fromJSON(json.history.initialState);
                }
                this.app.history.actions = json.history.actions.map(action => {
                  if (action.type === 'checkpoint') {
                    return {
                      ...action,
                      state: BoardState.fromJSON(action.state)
                    };
                  }
                  return action;
                });
                this.app.history.currentIndex = json.history.currentIndex;

                // Restore initial board
                if (json.initialBoard) {
                  this.app.initialBoard = BoardState.fromJSON(json.initialBoard);
                } else {
                  this.app.initialBoard = board.clone();
                }

                this.app.render();
                resolve(true);
              } else if (json.version === 1 && json.history) {
                // Version 1: State-based history (backward compatibility)
                const board = BoardState.fromJSON(json.currentState);
                this.app.board = board;
                this.app.laws = new ConservationLaws(board);
                this.app.renderer.board = board;
                this.app.history.clear();
                this.app.history.setInitialState(board);
                this.app.initialBoard = json.initialBoard ? BoardState.fromJSON(json.initialBoard) : board.clone();
                this.app.render();
                resolve(true);
              } else {
                // Very old format - just board state
                const board = BoardState.fromJSON(json);
                this.app.board = board;
                this.app.laws = new ConservationLaws(board);
                this.app.renderer.board = board;
                this.app.history.clear();
                this.app.history.setInitialState(board);
                this.app.initialBoard = board.clone();
                this.app.render();
                resolve(true);
              }
            } catch (err) {
              reject(err);
            }
          };

          reader.onerror = reject;
          reader.readAsText(file);
        });
      }
    }

    // ========== Action Statistics Graph Class ==========
    class ActionStatsGraph {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.width = canvas.width;
        this.height = canvas.height;
        this.padding = { top: 20, right: 20, bottom: 40, left: 60 };

        // Action type colors
        this.colors = {
          'gRight': '#3b82f6',    // blue
          'gLeft': '#8b5cf6',     // purple
          'hUp': '#10b981',       // green
          'hDown': '#f59e0b',     // amber
          'basisLaw': '#ef4444',  // red
          'reverseBasisLaw': '#ec4899', // pink
          'total': '#1f2937'      // dark gray
        };

        this.labels = {
          'gRight': '‚Üí Right',
          'gLeft': '‚Üê Left',
          'hUp': '‚Üë Up',
          'hDown': '‚Üì Down',
          'basisLaw': 'Basis Law',
          'reverseBasisLaw': 'Rev Basis',
          'total': 'Total'
        };
      }

      // Compute cumulative counts for each action type over time
      computeStats(actions, currentIndex) {
        const stats = {
          'gRight': [],
          'gLeft': [],
          'hUp': [],
          'hDown': [],
          'basisLaw': [],
          'reverseBasisLaw': [],
          'total': []
        };

        const counts = {
          'gRight': 0,
          'gLeft': 0,
          'hUp': 0,
          'hDown': 0,
          'basisLaw': 0,
          'reverseBasisLaw': 0
        };

        let total = 0;

        // Only process actions up to currentIndex
        const endIndex = Math.min(currentIndex + 1, actions.length);

        for (let i = 0; i < endIndex; i++) {
          const action = actions[i];

          // Skip checkpoint actions in the graph
          if (action.type === 'checkpoint') {
            continue;
          }

          if (counts.hasOwnProperty(action.type)) {
            counts[action.type]++;
            total++;
          }

          // Record cumulative counts
          for (const type in counts) {
            stats[type].push(counts[type]);
          }
          stats.total.push(total);
        }

        return { stats, counts, total };
      }

      render(actions, currentIndex) {
        const ctx = this.ctx;

        // Clear canvas
        ctx.clearRect(0, 0, this.width, this.height);

        if (actions.length === 0 || currentIndex < 0) {
          ctx.fillStyle = '#999';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No actions recorded yet', this.width / 2, this.height / 2);
          return;
        }

        const { stats, counts, total } = this.computeStats(actions, currentIndex);

        // Find max value for y-axis scaling
        const maxValue = Math.max(...stats.total, 1);
        const dataPoints = stats.total.length;

        if (dataPoints === 0) {
          ctx.fillStyle = '#999';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No actions to display', this.width / 2, this.height / 2);
          return;
        }

        // Draw axes
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(this.padding.left, this.padding.top);
        ctx.lineTo(this.padding.left, this.height - this.padding.bottom);
        ctx.lineTo(this.width - this.padding.right, this.height - this.padding.bottom);
        ctx.stroke();

        // Draw y-axis labels
        ctx.fillStyle = '#666';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';

        const ySteps = 5;
        for (let i = 0; i <= ySteps; i++) {
          const value = Math.round((maxValue * i) / ySteps);
          const y = this.height - this.padding.bottom - (i * (this.height - this.padding.top - this.padding.bottom) / ySteps);
          ctx.fillText(value.toString(), this.padding.left - 10, y);

          // Draw grid line
          ctx.strokeStyle = '#f0f0f0';
          ctx.beginPath();
          ctx.moveTo(this.padding.left, y);
          ctx.lineTo(this.width - this.padding.right, y);
          ctx.stroke();
        }

        // Draw x-axis label
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('Action Index', this.width / 2, this.height - this.padding.bottom + 25);

        // Draw y-axis label
        ctx.save();
        ctx.translate(15, this.height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Cumulative Count', 0, 0);
        ctx.restore();

        // Helper function to map data to canvas coordinates
        const mapX = (index) => {
          return this.padding.left + (index / (dataPoints - 1)) * (this.width - this.padding.left - this.padding.right);
        };

        const mapY = (value) => {
          return this.height - this.padding.bottom - (value / maxValue) * (this.height - this.padding.top - this.padding.bottom);
        };

        // Draw lines for each action type
        const typesToDraw = ['gRight', 'gLeft', 'hUp', 'hDown', 'basisLaw', 'reverseBasisLaw', 'total'];

        for (const type of typesToDraw) {
          const data = stats[type];
          if (data.length === 0) continue;

          ctx.strokeStyle = this.colors[type];
          ctx.lineWidth = type === 'total' ? 2.5 : 1.5;
          ctx.beginPath();

          for (let i = 0; i < data.length; i++) {
            const x = mapX(i);
            const y = mapY(data[i]);

            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }

          ctx.stroke();
        }

        // Update legend
        this.updateLegend(counts, total);

        // Update summary
        this.updateSummary(total, currentIndex, actions.length);
      }

      updateLegend(counts, total) {
        const legendDiv = document.getElementById('action-stats-legend');
        if (!legendDiv) return;

        const items = [
          ...Object.keys(counts).map(type => ({
            type,
            count: counts[type],
            label: this.labels[type]
          })),
          { type: 'total', count: total, label: this.labels.total }
        ];

        legendDiv.innerHTML = items.map(item => `
          <div style="display: flex; align-items: center; gap: 5px;">
            <div style="width: 20px; height: 3px; background: ${this.colors[item.type]};"></div>
            <span style="color: #666;">${item.label}: <strong>${item.count}</strong></span>
          </div>
        `).join('');
      }

      updateSummary(total, currentIndex, totalActions) {
        const summaryDiv = document.getElementById('action-stats-summary');
        if (!summaryDiv) return;

        const checkpointCount = totalActions - total; // Checkpoints are not counted in stats
        summaryDiv.textContent = `Showing ${currentIndex + 1} of ${totalActions} actions (${checkpointCount} checkpoints excluded from graph)`;
      }
    }

    // ========== Entropy Graph Class ==========
    class EntropyGraph {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.width = canvas.width;
        this.height = canvas.height;
        this.padding = { top: 20, right: 80, bottom: 40, left: 60 };

        // Metric colors
        this.colors = {
          'entropy': '#8b5cf6',      // purple
          'whiteForce': '#10b981'    // green
        };

        this.labels = {
          'entropy': 'Board Entropy',
          'whiteForce': 'Balanced Force'
        };
      }

      // Compute entropy and white force over time by replaying actions
      computeMetrics(initialState, actions, currentIndex) {
        const entropyData = [];
        const whiteForceData = [];

        if (!initialState) {
          return { entropyData, whiteForceData };
        }

        // Start with initial state
        let state = initialState.clone();
        entropyData.push(state.calculateEntropy());
        whiteForceData.push(state.calculateWhiteForce());

        // Only process actions up to currentIndex
        const endIndex = Math.min(currentIndex + 1, actions.length);

        for (let i = 0; i < endIndex; i++) {
          const action = actions[i];

          // Apply action to state
          if (action.type === 'checkpoint') {
            state = action.state.clone();
          } else {
            const laws = new ConservationLaws(state);

            switch (action.type) {
              case 'gRight':
                laws.applyGMultiplyRight(action.j, action.i, action.count);
                break;
              case 'gLeft':
                laws.applyGMultiplyLeft(action.j, action.i, action.count);
                break;
              case 'hUp':
                laws.applyHMultiplyUp(action.j, action.i, action.count);
                break;
              case 'hDown':
                laws.applyHMultiplyDown(action.j, action.i, action.count);
                break;
              case 'basisLaw':
                laws.applySpecial(action.j, action.i, action.count);
                break;
              case 'reverseBasisLaw':
                laws.applyReverseSpecial(action.j, action.i, action.count);
                break;
            }
          }

          // Record metrics
          entropyData.push(state.calculateEntropy());
          whiteForceData.push(state.calculateWhiteForce());
        }

        return { entropyData, whiteForceData };
      }

      render(initialState, actions, currentIndex) {
        const ctx = this.ctx;

        // Clear canvas
        ctx.clearRect(0, 0, this.width, this.height);

        if (!initialState || currentIndex < -1) {
          ctx.fillStyle = '#999';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No data to display', this.width / 2, this.height / 2);
          return;
        }

        const { entropyData, whiteForceData } = this.computeMetrics(initialState, actions, currentIndex);

        if (entropyData.length === 0) {
          ctx.fillStyle = '#999';
          ctx.font = '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('No metrics to display', this.width / 2, this.height / 2);
          return;
        }

        // Find max values for scaling
        const maxEntropy = Math.max(...entropyData, 1);
        const maxWhiteForce = Math.max(...whiteForceData, 1);
        const dataPoints = entropyData.length;

        // Draw axes
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(this.padding.left, this.padding.top);
        ctx.lineTo(this.padding.left, this.height - this.padding.bottom);
        ctx.lineTo(this.width - this.padding.right, this.height - this.padding.bottom);
        ctx.stroke();

        // Draw left y-axis labels (Entropy)
        ctx.fillStyle = this.colors.entropy;
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';

        const ySteps = 5;
        for (let i = 0; i <= ySteps; i++) {
          const value = (maxEntropy * i) / ySteps;
          const y = this.height - this.padding.bottom - (i * (this.height - this.padding.top - this.padding.bottom) / ySteps);
          ctx.fillText(value.toFixed(1), this.padding.left - 10, y);

          // Draw grid line
          ctx.strokeStyle = '#f0f0f0';
          ctx.beginPath();
          ctx.moveTo(this.padding.left, y);
          ctx.lineTo(this.width - this.padding.right, y);
          ctx.stroke();
        }

        // Draw right y-axis labels (Balanced Force)
        ctx.fillStyle = this.colors.whiteForce;
        ctx.textAlign = 'left';
        for (let i = 0; i <= ySteps; i++) {
          const value = (maxWhiteForce * i) / ySteps;
          const y = this.height - this.padding.bottom - (i * (this.height - this.padding.top - this.padding.bottom) / ySteps);
          ctx.fillText(value.toExponential(1), this.width - this.padding.right + 10, y);
        }

        // Draw x-axis label
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText('Action Index', this.width / 2, this.height - this.padding.bottom + 25);

        // Draw left y-axis label (Entropy)
        ctx.save();
        ctx.fillStyle = this.colors.entropy;
        ctx.translate(15, this.height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Entropy', 0, 0);
        ctx.restore();

        // Draw right y-axis label (Balanced Force)
        ctx.save();
        ctx.fillStyle = this.colors.whiteForce;
        ctx.translate(this.width - 15, this.height / 2);
        ctx.rotate(Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Balanced Force', 0, 0);
        ctx.restore();

        // Helper functions to map data to canvas coordinates
        const mapX = (index) => {
          return this.padding.left + (index / (dataPoints - 1)) * (this.width - this.padding.left - this.padding.right);
        };

        const mapYEntropy = (value) => {
          return this.height - this.padding.bottom - (value / maxEntropy) * (this.height - this.padding.top - this.padding.bottom);
        };

        const mapYWhiteForce = (value) => {
          return this.height - this.padding.bottom - (value / maxWhiteForce) * (this.height - this.padding.top - this.padding.bottom);
        };

        // Draw entropy line
        ctx.strokeStyle = this.colors.entropy;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < entropyData.length; i++) {
          const x = mapX(i);
          const y = mapYEntropy(entropyData[i]);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();

        // Draw white force line
        ctx.strokeStyle = this.colors.whiteForce;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < whiteForceData.length; i++) {
          const x = mapX(i);
          const y = mapYWhiteForce(whiteForceData[i]);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();

        // Update legend and summary
        const currentEntropy = entropyData[entropyData.length - 1];
        const currentWhiteForce = whiteForceData[whiteForceData.length - 1];
        this.updateLegend(currentEntropy, currentWhiteForce);
        this.updateSummary(currentIndex, actions.length);
      }

      updateLegend(entropy, whiteForce) {
        const legendDiv = document.getElementById('entropy-legend');
        if (!legendDiv) return;

        legendDiv.innerHTML = `
          <div style="display: flex; align-items: center; gap: 5px;">
            <div style="width: 20px; height: 3px; background: ${this.colors.entropy};"></div>
            <span style="color: #666;">${this.labels.entropy}: <strong>${entropy.toFixed(2)}</strong></span>
          </div>
          <div style="display: flex; align-items: center; gap: 5px;">
            <div style="width: 20px; height: 3px; background: ${this.colors.whiteForce};"></div>
            <span style="color: #666;">${this.labels.whiteForce}: <strong>${whiteForce.toExponential(2)}</strong></span>
          </div>
        `;
      }

      updateSummary(currentIndex, totalActions) {
        const summaryDiv = document.getElementById('entropy-summary');
        if (!summaryDiv) return;

        summaryDiv.textContent = `Showing metrics for ${currentIndex + 2} states (initial + ${currentIndex + 1} actions)`;
      }
    }

    // ========== Application Class ==========
    class Application {
      constructor() {
        this.board = null;
        this.history = new History();
        this.renderer = null;
        this.statsGraph = null;
        this.entropyGraph = null;
        this.laws = null;
        this.selectedCell = null;
        this.initialBoard = null;
        this.pendingAction = null;
        this.animationInterval = null;
        this.animationDelay = 500; // milliseconds between steps
        this.randomInterval = null;
        this.randomDelay = 500; // milliseconds between random actions
        this.statsPopup = null;
        this.entropyPopup = null;
      }

      initialize(o, e, g, h, q, x0) {
        if (o < 0 || e < 0 || g < 2 || h < 2 || q === 0 || x0 === 0) {
          throw new Error('Invalid parameters: o, e must be non-negative; g, h must be at least 2; q and x0 must be non-zero');
        }

        // Get p value from input
        const pInput = document.getElementById('input-p');
        const p = pInput ? parseP(pInput.value) : null;

        this.board = new BoardState(o, e, g, h, q, x0, p);
        this.generateInitialState();

        const canvas = document.getElementById('board-canvas');
        this.renderer = new Renderer(canvas, this.board);

        const statsCanvas = document.getElementById('action-stats-canvas');
        this.statsGraph = new ActionStatsGraph(statsCanvas);

        const entropyCanvas = document.getElementById('entropy-canvas');
        this.entropyGraph = new EntropyGraph(entropyCanvas);

        this.laws = new ConservationLaws(this.board);

        this.initialBoard = this.board.clone();
        this.history.clear();
        this.history.setInitialState(this.board);

        this.selectedCell = null;
        this.render();
        this.enableButtons();
      }

      generateInitialState() {
        // Get the current p value and parse its structure
        const pInput = document.getElementById('input-p');
        if (!pInput) {
          // Fallback if input doesn't exist
          this.board.set(-1, 0, this.board.x0);
          this.board.set(this.board.o - 1, this.board.e, -this.board.x0);
          return;
        }

        const p = parseP(pInput.value);
        if (isNaN(p) || p <= 0) {
          // Fallback to simple initialization
          this.board.set(-1, 0, this.board.x0);
          this.board.set(this.board.o - 1, this.board.e, -this.board.x0);
          return;
        }

        try {
          // Use the correct parsing function that handles even p values
          const { monomials } = parseBinaryToStructure(p);

          // Place x‚ÇÄ term at the start: x‚ÇÄ¬∑g^o at position (-1, 0)
          this.board.set(-1, 0, this.board.x0);

          // Place q coefficient for each monomial in k(g,h)
          for (const m of monomials) {
            const j = this.board.o - 1 - m.gPower;
            const i = m.hPower;
            this.board.set(j, i, this.board.q);
          }

          // Place -x‚ÇÄ term at the end: -x‚ÇÄ¬∑h^e at position (o-1, e)
          this.board.set(this.board.o - 1, this.board.e, -this.board.x0+this.board.get(this.board.o-1, this.board.e));

        } catch (err) {
          console.error('Error generating initial state:', err);
          // Fallback
          this.board.set(-1, 0, this.board.x0);
          this.board.set(this.board.o - 1, this.board.e, -this.board.x0);
        }
      }

      applyAction(action) {
        // Calculate polynomial sum before action
        const sumBefore = this.board.calculatePolynomialSum();

        const newBoard = this.board.clone();
        const newLaws = new ConservationLaws(newBoard);

        // Apply the action based on its type
        let success = false;
        switch (action.type) {
          case 'gRight':
            success = newLaws.applyGMultiplyRight(action.j, action.i, action.count);
            break;
          case 'gLeft':
            success = newLaws.applyGMultiplyLeft(action.j, action.i, action.count);
            break;
          case 'hUp':
            success = newLaws.applyHMultiplyUp(action.j, action.i, action.count);
            break;
          case 'hDown':
            success = newLaws.applyHMultiplyDown(action.j, action.i, action.count);
            break;
          case 'basisLaw':
            success = newLaws.applySpecial(action.j, action.i, action.count);
            break;
          case 'reverseBasisLaw':
            success = newLaws.applyReverseSpecial(action.j, action.i, action.count);
            break;
          case 'checkpoint':
            // For checkpoints, just set the board to the stored state
            this.board = action.state.clone();
            this.laws = new ConservationLaws(this.board);
            this.renderer.board = this.board;
            this.history.recordAction(action);
            this.render();
            return true;
        }

        if (success) {
          // Calculate polynomial sum after action
          const sumAfter = newBoard.calculatePolynomialSum();

          // Assert that the polynomial sum is preserved
          const tolerance = 1e-9; // Account for floating point errors
          if (Math.abs(sumBefore - sumAfter) > tolerance) {
            console.error('ASSERTION FAILED: Polynomial sum not preserved!');
            console.error(`Before: ${sumBefore}`);
            console.error(`After: ${sumAfter}`);
            console.error(`Difference: ${sumAfter - sumBefore}`);
            alert(`‚ö†Ô∏è Conservation law violation detected!\n\nPolynomial sum before: ${sumBefore}\nPolynomial sum after: ${sumAfter}\n\nThis action has been blocked.`);
            return false;
          }

          this.board = newBoard;
          this.laws = newLaws;
          this.renderer.board = newBoard;

          // Record the action in history
          this.history.recordAction(action);

          if (this.board.isZeroState()) {
            setTimeout(() => {
              alert('üéâ Zero state reached! The cycle has been proven.\n\nAll pebbles have been cancelled through conservation laws.');
            }, 100);
          }

          this.render();
          return true;
        }

        return false;
      }

      undo() {
        const action = this.history.getUndoAction();
        if (!action) return;

        // Try to apply inverse action (efficient for reversible actions)
        const inverseAction = this.history.getInverseAction(action);
        if (inverseAction) {
          // Apply inverse directly
          const newBoard = this.board.clone();
          const newLaws = new ConservationLaws(newBoard);

          let success = false;
          switch (inverseAction.type) {
            case 'gRight':
              success = newLaws.applyGMultiplyRight(inverseAction.j, inverseAction.i, inverseAction.count);
              break;
            case 'gLeft':
              success = newLaws.applyGMultiplyLeft(inverseAction.j, inverseAction.i, inverseAction.count);
              break;
            case 'hUp':
              success = newLaws.applyHMultiplyUp(inverseAction.j, inverseAction.i, inverseAction.count);
              break;
            case 'hDown':
              success = newLaws.applyHMultiplyDown(inverseAction.j, inverseAction.i, inverseAction.count);
              break;
            case 'basisLaw':
              success = newLaws.applySpecial(inverseAction.j, inverseAction.i, inverseAction.count);
              break;
            case 'reverseBasisLaw':
              success = newLaws.applyReverseSpecial(inverseAction.j, inverseAction.i, inverseAction.count);
              break;
          }

          if (success) {
            this.board = newBoard;
            this.laws = newLaws;
            this.renderer.board = newBoard;
            this.render();
            return;
          }
        }

        // Fallback: rebuild state from history (for checkpoints or if inverse failed)
        const state = this.history.getCurrentState();
        if (state) {
          this.board = state;
          this.laws = new ConservationLaws(this.board);
          this.renderer.board = this.board;
          this.render();
        }
      }

      redo() {
        const action = this.history.getRedoAction();
        if (!action) return;

        // Rebuild state from history by replaying
        const state = this.history.getCurrentState();
        if (state) {
          this.board = state;
          this.laws = new ConservationLaws(this.board);
          this.renderer.board = this.board;
          this.render();
        }
      }

      reset() {
        this.stopAnimation();
        this.stopRandomExecution();
        this.stopLocalMinimiserExecution();
        if (this.initialBoard) {
          this.board = this.initialBoard.clone();
          this.laws = new ConservationLaws(this.board);
          this.renderer.board = this.board;
          this.history.clear();
          this.history.setInitialState(this.board);
          this.selectedCell = null;
          this.renderer.selectedCell = null;
          this.render();
        }
      }

      resetK() {
        // Reset q¬∑k clears the board to show only x‚ÇÄ¬∑d(g,h) part
        // This allows user to reconstruct q¬∑k(g,h) to complete the identity
        // This is a destructive operation, so we create a checkpoint

        // Create the new board state
        const newBoard = this.board.clone();
        const newLaws = new ConservationLaws(newBoard);
        newLaws.applyResetK();

        // Create a checkpoint action
        const checkpointAction = {
          type: 'checkpoint',
          state: newBoard,
          reason: 'resetK'
        };

        return this.applyAction(checkpointAction);
      }

      performRandomAction() {
        // Find all cells with available actions
        const cellsWithActions = [];

        for (let j = this.board.minCol; j <= this.board.maxCol; j++) {
          for (let i = this.board.minRow; i <= this.board.maxRow; i++) {
            const count = Math.abs(this.board.get(j, i));
            if (count === 0) continue;

            const availableActions = [];

            // Check all possible actions at this cell
            if (this.laws.canApplyGMultiplyRight(j, i)) {
              availableActions.push({
                type: 'gRight',
                j,
                i,
                maxCount: count,
                moveCell: { j: j + 1, i }
              });
            }

            if (j > this.board.minCol && this.laws.canApplyGMultiplyLeft(j - 1, i)) {
              const maxSets = Math.floor(count / this.board.g);
              if (maxSets > 0) {
                availableActions.push({
                  type: 'gLeft',
                  j: j - 1,
                  i,
                  maxCount: maxSets,
                  moveCell: { j: j - 1, i }
                });
              }
            }

            if (this.laws.canApplyHMultiplyDown(j, i)) {
              availableActions.push({
                type: 'hDown',
                j,
                i,
                maxCount: count,
                moveCell: { j, i: i - 1 }
              });
            }

            if (this.laws.canApplyHMultiplyUp(j, i)) {
              const maxSets = Math.floor(count / this.board.h);
              if (maxSets > 0) {
                availableActions.push({
                  type: 'hUp',
                  j,
                  i,
                  maxCount: maxSets,
                  moveCell: { j, i: i + 1 }
                });
              }
            }

            if (this.laws.canApplySpecial(j, i)) {
              availableActions.push({
                type: 'basisLaw',
                j,
                i,
                maxCount: count,
                moveCell: null
              });
            }

            if (this.laws.canApplyReverseSpecial(j, i)) {
              availableActions.push({
                type: 'reverseBasisLaw',
                j,
                i,
                maxCount: count,
                moveCell: null
              });
            }

            if (availableActions.length > 0) {
              cellsWithActions.push({ j, i, actions: availableActions });
            }
          }
        }

        if (cellsWithActions.length === 0) {
          this.stopRandomExecution();
          return false;
        }

        // Pick a random cell
        const randomCell = cellsWithActions[Math.floor(Math.random() * cellsWithActions.length)];

        // Pick a random action from that cell
        const randomAction = randomCell.actions[Math.floor(Math.random() * randomCell.actions.length)];

        // Pick a random count between 1 and maxCount
        const randomCount = Math.floor(Math.random() * randomAction.maxCount) + 1;

        // Execute the action
        const action = {
          type: randomAction.type,
          j: randomAction.j,
          i: randomAction.i,
          count: randomCount
        };

        const success = this.applyAction(action);

        // Update selected cell
        if (success) {
          if (randomAction.moveCell) {
            this.selectedCell = randomAction.moveCell;
          } else {
            this.selectedCell = { j: randomAction.j, i: randomAction.i };
          }
          this.renderer.selectedCell = this.selectedCell;
        }

        return success;
      }

      performLocalMinimiserAction() {
        // Get current entropy
        const currentEntropy = this.board.calculateEntropy();

        // Find all possible actions and evaluate their entropy loss
        const candidateActions = [];

        for (let j = this.board.minCol; j <= this.board.maxCol; j++) {
          for (let i = this.board.minRow; i <= this.board.maxRow; i++) {
            const count = Math.abs(this.board.get(j, i));
            if (count === 0) continue;

            // List of all possible action types (in alphabetical order for tie-breaking)
            const actionTypes = [
              { name: 'basisLaw', canApply: () => this.laws.canApplySpecial(j, i) },
              { name: 'gLeft', canApply: () => j > this.board.minCol && this.laws.canApplyGMultiplyLeft(j - 1, i) },
              { name: 'gRight', canApply: () => this.laws.canApplyGMultiplyRight(j, i) },
              { name: 'hDown', canApply: () => this.laws.canApplyHMultiplyDown(j, i) },
              { name: 'hUp', canApply: () => this.laws.canApplyHMultiplyUp(j, i) },
              { name: 'reverseBasisLaw', canApply: () => this.laws.canApplyReverseSpecial(j, i) }
            ];

            for (const actionType of actionTypes) {
              if (!actionType.canApply()) continue;

              // Clone board and test the action
              const testBoard = this.board.clone();
              const testLaws = new ConservationLaws(testBoard);

              let actionJ = j;
              let actionI = i;
              let moveCell = { j, i };

              // Apply the action with count=1
              let success = false;
              if (actionType.name === 'gRight') {
                success = testLaws.applyGMultiplyRight(j, i, 1);
                moveCell = { j: j + 1, i };
              } else if (actionType.name === 'gLeft') {
                actionJ = j - 1;
                success = testLaws.applyGMultiplyLeft(j - 1, i, 1);
                moveCell = { j: j - 1, i };
              } else if (actionType.name === 'hUp') {
                success = testLaws.applyHMultiplyUp(j, i, 1);
                moveCell = { j, i: i + 1 };
              } else if (actionType.name === 'hDown') {
                success = testLaws.applyHMultiplyDown(j, i, 1);
                moveCell = { j, i: i - 1 };
              } else if (actionType.name === 'basisLaw') {
                success = testLaws.applySpecial(j, i, 1);
              } else if (actionType.name === 'reverseBasisLaw') {
                success = testLaws.applyReverseSpecial(j, i, 1);
              }

              if (success) {
                const newEntropy = testBoard.calculateEntropy();
                const entropyLoss = currentEntropy - newEntropy;

                candidateActions.push({
                  type: actionType.name,
                  j: actionJ,
                  i: actionI,
                  entropyLoss,
                  originalJ: j,  // For tie-breaking
                  originalI: i,  // For tie-breaking
                  moveCell
                });
              }
            }
          }
        }

        if (candidateActions.length === 0) {
          this.stopLocalMinimiserExecution();
          return false;
        }

        // Sort by: max entropy loss, then lowest j, then lowest i, then alphabetical action name
        candidateActions.sort((a, b) => {
          if (a.entropyLoss !== b.entropyLoss) {
            return b.entropyLoss - a.entropyLoss;  // Descending (max first)
          }
          if (a.originalJ !== b.originalJ) {
            return a.originalJ - b.originalJ;  // Ascending (lowest first)
          }
          if (a.originalI !== b.originalI) {
            return a.originalI - b.originalI;  // Ascending (lowest first)
          }
          return a.type.localeCompare(b.type);  // Alphabetical
        });

        // Sample N using inverse uniform distribution: u ~ U(0,1), N = 2^ceil(log2(1/u))
        // This creates variable-sized candidate pool with logarithmic distribution
        // Heavily favors small N (exploitation) but occasionally allows larger N (exploration)
        const u = Math.max(Math.random(), 1e-6);  // Avoid division by zero
        const inverse = 1 / u;
        const nextPowerOf2 = Math.pow(2, Math.ceil(Math.log2(inverse)));
        const topN = Math.min(nextPowerOf2, candidateActions.length);
        const topCandidates = candidateActions.slice(0, topN);
        const bestAction = topCandidates[Math.floor(Math.random() * topCandidates.length)];

        // Execute the action
        const action = {
          type: bestAction.type,
          j: bestAction.j,
          i: bestAction.i,
          count: 1  // Always use 1 for local minimiser mode
        };

        const success = this.applyAction(action);

        // Update selected cell
        if (success) {
          this.selectedCell = bestAction.moveCell;
          this.renderer.selectedCell = this.selectedCell;
        }

        return success;
      }

      startRandomExecution() {
        if (this.randomInterval) {
          this.stopRandomExecution();
          return;
        }

        // Stop local minimiser if running (mutually exclusive)
        this.stopLocalMinimiserExecution();

        // Update button text
        document.getElementById('random-btn').textContent = '‚è∏ Stop Random';

        // Perform first action immediately
        this.performRandomAction();

        // Start interval
        this.randomInterval = setInterval(() => {
          if (!this.performRandomAction()) {
            this.stopRandomExecution();
          }
        }, this.randomDelay);
      }

      stopRandomExecution() {
        if (this.randomInterval) {
          clearInterval(this.randomInterval);
          this.randomInterval = null;
          document.getElementById('random-btn').textContent = 'üé≤ Random (r)';
        }
      }

      startLocalMinimiserExecution() {
        if (this.localMinimiserInterval) {
          this.stopLocalMinimiserExecution();
          return;
        }

        // Stop random if running (mutually exclusive)
        this.stopRandomExecution();

        // Update button text
        document.getElementById('local-minimiser-btn').textContent = '‚è∏ Stop Local Minimiser';

        // Perform first action immediately
        this.performLocalMinimiserAction();

        // Start interval
        this.localMinimiserInterval = setInterval(() => {
          if (!this.performLocalMinimiserAction()) {
            this.stopLocalMinimiserExecution();
          }
        }, this.randomDelay);  // Use same delay as random
      }

      stopLocalMinimiserExecution() {
        if (this.localMinimiserInterval) {
          clearInterval(this.localMinimiserInterval);
          this.localMinimiserInterval = null;
          document.getElementById('local-minimiser-btn').textContent = 'üìâ Local Minimiser (m)';
        }
      }

      startAnimation() {
        if (this.animationInterval) {
          this.stopAnimation();
          return;
        }

        // Stop random and local minimiser execution if running
        this.stopRandomExecution();
        this.stopLocalMinimiserExecution();

        // Go to start of history (initialState)
        this.history.currentIndex = -1;
        this.board = this.history.initialState.clone();
        this.laws = new ConservationLaws(this.board);
        this.renderer.board = this.board;
        this.render();

        // Update button text
        document.getElementById('animate-btn').textContent = '‚è∏ Stop';

        // Start animation
        this.animationInterval = setInterval(() => {
          if (this.history.canRedo()) {
            this.redo();
          } else {
            this.stopAnimation();
          }
        }, this.animationDelay);
      }

      stopAnimation() {
        if (this.animationInterval) {
          clearInterval(this.animationInterval);
          this.animationInterval = null;
          document.getElementById('animate-btn').textContent = '‚ñ∂ Animate';
        }
      }

      render() {
        if (this.renderer) {
          this.renderer.render();
        }
        if (this.statsGraph) {
          this.statsGraph.render(this.history.actions, this.history.currentIndex);
        }
        if (this.entropyGraph) {
          this.entropyGraph.render(this.history.initialState, this.history.actions, this.history.currentIndex);
        }
        this.updatePolynomialDisplay();
        this.updateControlPanel();

        // Update popup windows if they exist
        this.updatePopups();
      }

      popoutStatsGraph() {
        if (this.statsPopup && !this.statsPopup.closed) {
          this.statsPopup.focus();
          return;
        }

        const features = 'width=800,height=450,left=100,top=100,resizable=yes,scrollbars=yes,toolbar=no,menubar=no,location=no,status=no';
        const popup = window.open('', 'ActionStats_' + Date.now(), features);
        this.statsPopup = popup;

        popup.document.write(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Action Statistics</title>
            <style>
              body { margin: 0; padding: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
              h2 { margin: 0 0 15px 0; color: #333; }
              canvas { border: 1px solid #ddd; border-radius: 4px; background: white; }
              #legend { margin-top: 10px; font-size: 12px; display: flex; flex-wrap: wrap; gap: 15px; }
              #summary { margin-top: 10px; font-size: 13px; color: #666; }
            </style>
          </head>
          <body>
            <h2>Action Statistics</h2>
            <canvas id="popup-stats-canvas" width="700" height="300"></canvas>
            <div id="legend"></div>
            <div id="summary"></div>
          </body>
          </html>
        `);
        popup.document.close();

        // Store reference for rendering
        popup.graphCanvas = popup.document.getElementById('popup-stats-canvas');
        popup.legendDiv = popup.document.getElementById('legend');
        popup.summaryDiv = popup.document.getElementById('summary');

        // Render immediately
        this.updatePopups();
      }

      popoutEntropyGraph() {
        if (this.entropyPopup && !this.entropyPopup.closed) {
          this.entropyPopup.focus();
          return;
        }

        const features = 'width=800,height=450,left=100,top=100,resizable=yes,scrollbars=yes,toolbar=no,menubar=no,location=no,status=no';
        const popup = window.open('', 'EntropyForce_' + Date.now(), features);
        this.entropyPopup = popup;

        popup.document.write(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Entropy & Force Analysis</title>
            <style>
              body { margin: 0; padding: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
              h2 { margin: 0 0 15px 0; color: #333; }
              canvas { border: 1px solid #ddd; border-radius: 4px; background: white; }
              #legend { margin-top: 10px; font-size: 12px; display: flex; flex-wrap: wrap; gap: 15px; }
              #summary { margin-top: 10px; font-size: 13px; color: #666; }
            </style>
          </head>
          <body>
            <h2>Entropy & Force Analysis</h2>
            <canvas id="popup-entropy-canvas" width="700" height="300"></canvas>
            <div id="legend"></div>
            <div id="summary"></div>
          </body>
          </html>
        `);
        popup.document.close();

        // Store reference for rendering
        popup.graphCanvas = popup.document.getElementById('popup-entropy-canvas');
        popup.legendDiv = popup.document.getElementById('legend');
        popup.summaryDiv = popup.document.getElementById('summary');

        // Render immediately
        this.updatePopups();
      }

      updatePopups() {
        // Update stats popup
        if (this.statsPopup && !this.statsPopup.closed && this.statsPopup.graphCanvas) {
          const tempGraph = new ActionStatsGraph(this.statsPopup.graphCanvas);
          // Temporarily override the legend/summary divs
          const origLegend = document.getElementById('action-stats-legend');
          const origSummary = document.getElementById('action-stats-summary');

          // Swap in popup divs
          const legendId = 'action-stats-legend';
          const summaryId = 'action-stats-summary';
          this.statsPopup.legendDiv.id = legendId;
          this.statsPopup.summaryDiv.id = summaryId;

          tempGraph.render(this.history.actions, this.history.currentIndex);

          // Restore original IDs
          this.statsPopup.legendDiv.id = 'legend';
          this.statsPopup.summaryDiv.id = 'summary';
        }

        // Update entropy popup
        if (this.entropyPopup && !this.entropyPopup.closed && this.entropyPopup.graphCanvas) {
          const tempGraph = new EntropyGraph(this.entropyPopup.graphCanvas);
          // Temporarily override the legend/summary divs
          const origLegend = document.getElementById('entropy-legend');
          const origSummary = document.getElementById('entropy-summary');

          // Swap in popup divs
          const legendId = 'entropy-legend';
          const summaryId = 'entropy-summary';
          this.entropyPopup.legendDiv.id = legendId;
          this.entropyPopup.summaryDiv.id = summaryId;

          tempGraph.render(this.history.initialState, this.history.actions, this.history.currentIndex);

          // Restore original IDs
          this.entropyPopup.legendDiv.id = 'legend';
          this.entropyPopup.summaryDiv.id = 'summary';
        }
      }

      updatePolynomialDisplay() {
        const terms = this.board.getPolynomial();
        const latexStr = this.formatPolynomialLatex(terms);
        const displayElement = document.getElementById('polynomial-display');

        // Render identity equation
        const identityElement = document.getElementById('polynomial-identity');
        const identityLatex = 'p(g,h) = q \\cdot k(g,h) - x_0 \\cdot d(g,h) = 0';
        try {
          katex.render(identityLatex, identityElement, {
            throwOnError: false,
            displayMode: false
          });
        } catch (e) {
          console.error('KaTeX identity rendering error:', e);
          identityElement.textContent = 'p(g,h) = q¬∑k(g,h) - x‚ÇÄ¬∑d(g,h) = 0';
        }

        // Render polynomial using KaTeX
        try {
          katex.render(latexStr, displayElement, {
            throwOnError: false,
            displayMode: true
          });
        } catch (e) {
          console.error('KaTeX rendering error:', e);
          displayElement.textContent = this.formatPolynomial(terms);
        }

        // Render k(g,h) polynomial
        this.renderKPolynomial();

        // Render d(g,h) polynomial
        this.renderDPolynomial();

        // Render basis law
        this.renderBasisLaw();

        // Render force balance equation
        this.renderForceBalance();

        // Render force conservation formulas
        this.renderForceConservation();

        const statusDiv = document.getElementById('polynomial-status');
        if (this.board.isZeroState()) {
          statusDiv.innerHTML = '<span class="status-badge status-zero">‚úì Zero state reached!</span>';
        } else {
          const nonZero = terms.filter(t => t.coeff !== 0).length;
          statusDiv.innerHTML = `<span class="status-badge status-active">${nonZero} non-zero term${nonZero !== 1 ? 's' : ''}</span>`;
        }
      }

      renderKPolynomial() {
        const p = parseP(document.getElementById('input-p').value);
        if (isNaN(p) || p <= 0) return;

        // Render heading
        const headingElement = document.getElementById('k-heading');
        try {
          katex.render('k(g,h)', headingElement, {
            throwOnError: false,
            displayMode: false
          });
        } catch (e) {
          headingElement.textContent = 'k(g,h)';
        }

        try {
          const structure = parseBinaryToStructure(p);
          const monomials = structure.monomials;

          // Format k(g,h) as sum of monomials
          const parts = monomials.map((m, idx) => {
            const sign = idx === 0 ? '' : ' + ';
            let term = '';
            if (m.gPower > 0) {
              term += 'g';
              if (m.gPower > 1) term += '^{' + m.gPower + '}';
            }
            if (m.hPower > 0) {
              term += 'h';
              if (m.hPower > 1) term += '^{' + m.hPower + '}';
            }
            if (term === '') term = '1';
            return sign + term;
          });

          const latexStr = parts.join('');
          const displayElement = document.getElementById('k-polynomial-display');

          katex.render(latexStr, displayElement, {
            throwOnError: false,
            displayMode: true
          });
        } catch (e) {
          console.error('Error rendering k(g,h):', e);
        }
      }

      renderDPolynomial() {
        const o = parseInt(document.getElementById('output-o').textContent);
        const e = parseInt(document.getElementById('output-e').textContent);

        if (isNaN(o) || isNaN(e)) return;

        // Render heading
        const headingElement = document.getElementById('d-heading');
        try {
          katex.render('d(g,h)', headingElement, {
            throwOnError: false,
            displayMode: false
          });
        } catch (e) {
          headingElement.textContent = 'd(g,h)';
        }

        // Format d(g,h) = h^e - g^o
        let latexStr = '';
        if (e > 0) {
          latexStr += 'h';
          if (e > 1) latexStr += '^{' + e + '}';
        } else {
          latexStr += '1';
        }

        latexStr += ' - ';

        if (o > 0) {
          latexStr += 'g';
          if (o > 1) latexStr += '^{' + o + '}';
        } else {
          latexStr += '1';
        }

        const displayElement = document.getElementById('d-polynomial-display');

        try {
          katex.render(latexStr, displayElement, {
            throwOnError: false,
            displayMode: true
          });
        } catch (e) {
          console.error('Error rendering d(g,h):', e);
        }
      }

      renderBasisLaw() {
        if (!this.board) return;

        const g = this.board.g;
        const h = this.board.h;
        const gPlus1 = g + 1;
        const digits = this.laws.toBaseH(gPlus1, h);

        // Build the formula: g = sum(digit_i * h^i) - 1
        const headingElement = document.getElementById('basis-law-heading');
        headingElement.textContent = 'Basis Law';

        let latexStr = 'g = ';
        let terms = [];

        // Add all non-zero terms from the base-h expansion (except power 0, which gets subtracted)
        for (let power = digits.length - 1; power >= 1; power--) {
          const digit = digits[digits.length - 1 - power];
          if (digit > 0) {
            let term = '';
            if (digit > 1) term += digit.toString();
            if (power > 1) {
              term += 'h^{' + power + '}';
            } else if (power === 1) {
              term += 'h';
            }
            if (term) terms.push(term);
          }
        }

        if (terms.length > 0) {
          latexStr += terms.join(' + ') + ' - 1';
        } else {
          latexStr += '-1';
        }

        const displayElement = document.getElementById('basis-law-display');
        const sectionElement = document.getElementById('basis-law-section');

        // Only show if there's a valid basis law
        if (terms.length > 0) {
          sectionElement.style.display = 'block';
          try {
            katex.render(latexStr, displayElement, {
              throwOnError: false,
              displayMode: true
            });
          } catch (e) {
            console.error('Error rendering basis law:', e);
            displayElement.textContent = latexStr.replace(/\^{(\d+)}/g, '^$1');
          }
        } else {
          sectionElement.style.display = 'none';
        }
      }

      renderForceBalance() {
        if (!this.board) return;

        const terms = this.board.getPolynomial();
        const whiteTerms = []; // Positive coefficients (white pebbles)
        const blackTerms = []; // Negative coefficients (black pebbles)

        // Separate terms by sign
        for (const term of terms) {
          if (term.coeff > 0) {
            whiteTerms.push(term);
          } else if (term.coeff < 0) {
            blackTerms.push(term);
          }
        }

        // Format white side (LHS)
        const formatSide = (terms) => {
          if (terms.length === 0) return '0';

          return terms.map((term, idx) => {
            const absCoeff = Math.abs(term.coeff);
            const sign = idx === 0 ? '' : ' + ';
            let str = sign;

            // Add coefficient if not 1, or if there are no powers
            if (absCoeff !== 1 || (term.gPower === 0 && term.hPower === 0)) {
              str += absCoeff.toString();
            }

            // Add g term
            if (term.gPower > 0) {
              str += 'g';
              if (term.gPower > 1) str += '^{' + term.gPower + '}';
            }

            // Add h term
            if (term.hPower > 0) {
              str += 'h';
              if (term.hPower > 1) str += '^{' + term.hPower + '}';
            }

            return str;
          }).join('');
        };

        const whiteSide = formatSide(whiteTerms);
        const blackSide = formatSide(blackTerms);

        const latexStr = whiteSide + ' = ' + blackSide;

        const displayElement = document.getElementById('force-display');
        try {
          katex.render(latexStr, displayElement, {
            throwOnError: false,
            displayMode: true
          });
        } catch (e) {
          console.error('Error rendering force balance:', e);
          displayElement.textContent = latexStr.replace(/\^{(\d+)}/g, '^$1');
        }
      }

      renderForceConservation() {
        // Only render once - check if already rendered
        const eqDiv = document.getElementById('force-conservation-eq');
        if (!eqDiv) return;

        // If already rendered, skip
        if (eqDiv.hasAttribute('data-rendered')) return;

        // Render inline LaTeX formulas for force conservation analogy
        const fieldSpan = document.querySelector('.force-field');
        const chargeSpan = document.querySelector('.force-charge');
        const forceSpan = document.querySelector('.force-at-square');

        if (!fieldSpan || !chargeSpan || !forceSpan) return;

        try {
          // Field strength at position (j,i)
          katex.render('(j,i)', fieldSpan, {
            throwOnError: false,
            displayMode: false
          });

          const fieldAfter = document.createElement('span');
          fieldAfter.textContent = ' is ';
          fieldSpan.parentNode.insertBefore(fieldAfter, fieldSpan.nextSibling);

          const fieldFormula = document.createElement('span');
          katex.render('g^{o-1-j} \\cdot h^i', fieldFormula, {
            throwOnError: false,
            displayMode: false
          });
          fieldAfter.parentNode.insertBefore(fieldFormula, fieldAfter.nextSibling);

          // Net charge
          katex.render('(j,i)', chargeSpan, {
            throwOnError: false,
            displayMode: false
          });

          const chargeAfter = document.createElement('span');
          chargeAfter.textContent = ' is ';
          chargeSpan.parentNode.insertBefore(chargeAfter, chargeSpan.nextSibling);

          const chargeFormula = document.createElement('span');
          katex.render('c_{j,i}', chargeFormula, {
            throwOnError: false,
            displayMode: false
          });
          chargeAfter.parentNode.insertBefore(chargeFormula, chargeAfter.nextSibling);

          // Force at each square
          katex.render('c_{j,i} \\cdot g^{o-1-j} \\cdot h^i', forceSpan, {
            throwOnError: false,
            displayMode: false
          });

          // Main conservation equation
          katex.render('\\sum_{j,i} c_{j,i} \\cdot g^{o-1-j} \\cdot h^i = 0', eqDiv, {
            throwOnError: false,
            displayMode: true
          });

          // Mark as rendered
          eqDiv.setAttribute('data-rendered', 'true');
        } catch (e) {
          console.error('Error rendering force conservation formulas:', e);
        }
      }

      formatPolynomial(terms) {
        if (terms.length === 0) return '0';

        const parts = terms
          .filter(t => t.coeff !== 0)
          .map((t, idx) => {
            const sign = t.coeff > 0 ? (idx === 0 ? '' : ' + ') : ' - ';
            const absCoeff = Math.abs(t.coeff);
            const coeffStr = absCoeff === 1 && (t.gPower > 0 || t.hPower > 0) ? '' : absCoeff.toString();

            let term = coeffStr;
            if (t.gPower > 0) {
              term += 'g';
              if (t.gPower > 1) term += '^' + t.gPower;
            }
            if (t.hPower > 0) {
              term += 'h';
              if (t.hPower > 1) term += '^' + t.hPower;
            }
            if (term === '') term = '1';

            if (t.gPower === 0 && t.hPower === 0 && (t.j !== -1 || t.i !== 0)) {
              term += 'q';
            }

            return sign + term + " = 0";
          });

        return parts.join('') || '0';
      }

      formatPolynomialLatex(terms) {
        if (terms.length === 0) return '0 = 0';

        const parts = terms
          .filter(t => t.coeff !== 0)
          .map((t, idx) => {
            const sign = t.coeff > 0 ? (idx === 0 ? '' : ' + ') : ' - ';
            const absCoeff = Math.abs(t.coeff);
            const coeffStr = absCoeff === 1 && (t.gPower > 0 || t.hPower > 0) ? '' : absCoeff.toString();

            let term = coeffStr;
            if (t.gPower > 0) {
              term += 'g';
              if (t.gPower > 1) term += '^{' + t.gPower + '}';
            }
            if (t.hPower > 0) {
              term += 'h';
              if (t.hPower > 1) term += '^{' + t.hPower + '}';
            }
            if (term === '') term = '1';

            if (t.gPower === 0 && t.hPower === 0 && (t.j !== -1 || t.i !== 0)) {
              term += 'q';
            }

            return sign + term;
          });

        return parts.join('') + ' = 0' || '0 = 0';
      }

      updateControlPanel() {
        document.getElementById('undo-btn').disabled = !this.history.canUndo();
        document.getElementById('redo-btn').disabled = !this.history.canRedo();
        document.getElementById('animate-btn').disabled = this.history.actions.length === 0;

        if (this.selectedCell) {
          const { j, i } = this.selectedCell;
          const count = this.board.get(j, i);
          const color = count > 0 ? 'white' : 'black';
          const gPower = this.board.o - 1 - j;
          const hPower = i;

          document.getElementById('selected-info').innerHTML =
            `Selected: (j=${j}, i=${i}) | ${Math.abs(count)} ${color} pebble${Math.abs(count) !== 1 ? 's' : ''} | Term: g^${gPower}¬∑h^${hPower}`;

          document.getElementById('g-right-btn').disabled = !this.laws.canApplyGMultiplyRight(j, i);
          document.getElementById('g-left-btn').disabled = (j <= this.board.minCol) || !this.laws.canApplyGMultiplyLeft(j - 1, i);
          document.getElementById('h-down-btn').disabled = !this.laws.canApplyHMultiplyDown(j, i);
          document.getElementById('h-up-btn').disabled = !this.laws.canApplyHMultiplyUp(j, i);
          document.getElementById('special-btn').disabled = !this.laws.canApplySpecial(j, i);
          document.getElementById('reverse-special-btn').disabled = !this.laws.canApplyReverseSpecial(j, i);
          // Reset q¬∑k, Random, and Local Minimiser are always available
        } else {
          document.getElementById('selected-info').textContent = 'No cell selected. Click a cell on the board to select it.';
          document.getElementById('g-right-btn').disabled = true;
          document.getElementById('g-left-btn').disabled = true;
          document.getElementById('h-down-btn').disabled = true;
          document.getElementById('h-up-btn').disabled = true;
          document.getElementById('special-btn').disabled = true;
          document.getElementById('reverse-special-btn').disabled = true;
          // Reset q¬∑k, Random, and Local Minimiser are always available
        }
      }

      enableButtons() {
        document.getElementById('reset-btn').disabled = false;
        document.getElementById('copy-url-btn').disabled = false;
        document.getElementById('save-local-btn').disabled = false;
        document.getElementById('export-json-btn').disabled = false;
      }

      showInputModal(title, description, max, callback, defaultValue = 1) {
        const modal = document.getElementById('input-modal');
        const input = document.getElementById('modal-input');

        document.getElementById('modal-title').textContent = title;
        document.getElementById('modal-description').textContent = description;
        input.value = Math.min(defaultValue, max);
        input.max = max;

        modal.classList.add('active');
        input.focus();

        const confirm = () => {
          const value = parseInt(input.value);
          if (value > 0 && value <= max) {
            modal.classList.remove('active');
            callback(value);
          }
        };

        const cancel = () => {
          modal.classList.remove('active');
        };

        document.getElementById('modal-confirm').onclick = confirm;
        document.getElementById('modal-cancel').onclick = cancel;

        input.onkeypress = (e) => {
          if (e.key === 'Enter') confirm();
          if (e.key === 'Escape') cancel();
        };
      }
    }

    // ========== Initialize Application ==========
    const app = new Application();
    const persistence = new Persistence(app);

    // Parse p input (accepts decimal, binary "0b1011", or OE notation "OEEOEE")
    function parseP(value) {
      if (typeof value === 'string') {
        value = value.trim();

        // Check for binary string like "0b1011"
        if (value.startsWith('0b') || value.startsWith('0B')) {
          return parseInt(value.substring(2), 2);
        }

        // Check for OE notation like "OEEEOEEOEE"
        // O = odd bit (1), E = even bit (0)
        // Leftmost symbol is LSB, no stop bit included
        if (/^[OE]+$/i.test(value)) {
          let bits = '';
          // Convert OE to binary (left to right = LSB to MSB)
          for (let i = 0; i < value.length; i++) {
            bits += (value[i].toUpperCase() === 'O') ? '1' : '0';
          }
          // Add stop bit at the end (highest bit)
          bits += '1';
          // Reverse to convert from LSB-first to MSB-first (standard binary)
          bits = bits.split('').reverse().join('');
          return parseInt(bits, 2);
        }
      }

      // Regular integer
      return parseInt(value, 10);
    }

    // Update URL query parameters to reflect current p, g, h values
    function updateURLParams() {
      const p = document.getElementById('input-p').value;
      const g = document.getElementById('input-g').value;
      const h = document.getElementById('input-h').value;

      const url = new URL(window.location.href);
      // Remove old state parameter if present (query params take precedence)
      url.searchParams.delete('state');
      // Remove anchor when manually changing inputs (will be reset to current p on next display)
      url.searchParams.delete('anchor');
      url.searchParams.set('p', p);
      url.searchParams.set('g', g);
      url.searchParams.set('h', h);

      // Update URL without reloading the page
      window.history.replaceState({}, '', url);
    }

    // Update binary representation
    // Convert p to OE notation
    function toOENotation(p) {
      const binary = p.toString(2);
      const bits = binary.split('').reverse(); // LSB first
      let oe = '';
      // Skip the stop bit (highest bit)
      for (let i = 0; i < bits.length - 1; i++) {
        oe += bits[i] === '1' ? 'O' : 'E';
      }
      return oe;
    }

    function updateBinaryDisplay() {
      const p = parseP(document.getElementById('input-p').value);
      if (!isNaN(p) && p > 0) {
        const pValue = p;
        const bValue = '0b' + p.toString(2);
        const oeValue = toOENotation(p);

        const pLink = document.getElementById('output-p');
        const bLink = document.getElementById('output-b');
        const oeLink = document.getElementById('output-oe');

        pLink.textContent = pValue;
        bLink.textContent = bValue;
        oeLink.textContent = oeValue;

        // Update link hrefs to use the respective p format
        const g = document.getElementById('input-g').value;
        const h = document.getElementById('input-h').value;
        pLink.href = `?p=${pValue}&g=${g}&h=${h}`;
        bLink.href = `?p=${bValue}&g=${g}&h=${h}`;
        oeLink.href = `?p=${oeValue}&g=${g}&h=${h}`;
      }
    }

    // Parse binary parameter p to extract cycle structure
    function parseBinaryToStructure(p) {
      const binary = p.toString(2);
      const bits = binary.split('').reverse(); // Read right to left

      const monomials = [];
      let hExponent = 0;
      let i = 0;

      // Count initial 0s (E bits) for even p values
      while (i < bits.length - 1 && bits[i] === '0') {
        hExponent++;
        i++;
      }

      // Parse monomials from right to left, excluding stop bit
      while (i < bits.length - 1) {
        if (bits[i] === '1') {
          // Record monomial at current h exponent
          monomials.push({ hPower: hExponent });
          i++;

          // Count following even bits (run of 0s)
          let evenCount = 0;
          while (i < bits.length - 1 && bits[i] === '0') {
            evenCount++;
            i++;
          }
          hExponent += evenCount;
        } else {
          // Safety: skip unexpected bits (shouldn't happen in valid patterns)
          i++;
        }
      }

      const o = monomials.length;
      const e = hExponent;

      // Assign g powers (decreasing from o-1 to 0)
      for (let j = 0; j < monomials.length; j++) {
        monomials[j].gPower = o - 1 - j;
      }

      return { o, e, monomials };
    }

    // Compute k(g,h) from monomial structure
    function computeK(monomials, g, h) {
      let sum = 0;
      for (const m of monomials) {
        sum += Math.pow(g, m.gPower) * Math.pow(h, m.hPower);
      }
      return sum;
    }

    // Compute GCD using Euclidean algorithm
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      while (b !== 0) {
        const temp = b;
        b = a % b;
        a = temp;
      }
      return a;
    }

    // Enumerate p-cycle by rotating lower bits
    function enumeratePCycle(p) {
      // Find the position of the stop bit (highest bit)
      const binary = p.toString(2);
      const bitLength = binary.length;
      const stopBitPos = bitLength - 1;
      const stopBitMask = 1 << stopBitPos;
      const lowerBitsMask = stopBitMask - 1;

      const cycle = [];
      let current = p;

      do {
        cycle.push(current);

        // Strip stop bit
        const lowerBits = current & lowerBitsMask;

        // Rotate right: LSB goes to MSB of lower bits (not stop bit position)
        const lsb = lowerBits & 1;
        const rotated = (lowerBits >> 1) | (lsb << (stopBitPos - 1));

        // Add stop bit back
        current = rotated | stopBitMask;

      } while (current !== p);

      return cycle;
    }

    // Calculate x-cycle from p-cycle
    function calculateXCycle(pCycle, g, h) {
      const xCycle = [];

      for (const p of pCycle) {
        try {
          const structure = parseBinaryToStructure(p);
          const k = computeK(structure.monomials, g, h);
          const d = Math.pow(h, structure.e) - Math.pow(g, structure.o);
          const gcdValue = gcd(k, d);
          const x0 = Math.round(k / gcdValue);

          xCycle.push({ p, x0 });
        } catch (err) {
          console.error('Error calculating x for p=' + p, err);
        }
      }

      return xCycle;
    }

    // Display x-cycle below the board
    function displayXCycle() {
      const currentP = parseP(document.getElementById('input-p').value);
      const g = parseInt(document.getElementById('input-g').value);
      const h = parseInt(document.getElementById('input-h').value);

      const container = document.getElementById('x-cycle-display');
      if (!container) return;

      if (isNaN(currentP) || currentP <= 0 || isNaN(g) || g < 2 || isNaN(h) || h < 2) {
        container.innerHTML = '';
        return;
      }

      try {
        // Get anchor from URL or use current p as default
        let url = new URL(window.location.href);
        let anchorP = url.searchParams.has('anchor')
          ? parseInt(url.searchParams.get('anchor'))
          : currentP;

        // If no anchor was set, set it now to preserve cycle order
        if (!url.searchParams.has('anchor')) {
          url.searchParams.set('anchor', anchorP);
          window.history.replaceState({}, '', url);
        }

        // Generate p-cycle from anchor point and calculate corresponding x values
        const pCycle = enumeratePCycle(anchorP);
        const xCycle = calculateXCycle(pCycle, g, h);

        let html = '<strong>x-cycle:</strong> [';

        xCycle.forEach((item, idx) => {
          if (idx > 0) html += ', ';

          // Check if this item's p matches currentP
          const isCurrent = (item.p == currentP);

          if (isCurrent) {
            // Current element - show as plain text, no link
            html += `<span>${item.x0}</span>`;
          } else {
            // Other elements - add clickable link
            html += `<a href="#" class="x-cycle-link" data-p="${item.p}" data-g="${g}" data-h="${h}" data-anchor="${anchorP}" style="cursor:pointer;" title="p=${item.p}">${item.x0}</a>`;
          }
        });

        html += ']';
        container.innerHTML = html;

        // Add click handlers to x-cycle links
        const links = container.querySelectorAll('.x-cycle-link');
        links.forEach(link => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const newP = link.getAttribute('data-p');
            const newG = link.getAttribute('data-g');
            const newH = link.getAttribute('data-h');
            const anchor = link.getAttribute('data-anchor');

            // Update input fields
            document.getElementById('input-p').value = newP;
            document.getElementById('input-g').value = newG;
            document.getElementById('input-h').value = newH;

            // Update derived parameters and display
            updateBinaryDisplay();
            updateDerivedParameters();

            // Update URL without page reload, preserving anchor
            const url = new URL(window.location.href);
            url.searchParams.set('p', newP);
            url.searchParams.set('g', newG);
            url.searchParams.set('h', newH);
            url.searchParams.set('anchor', anchor);
            window.history.pushState({}, '', url);

            // Reinitialize board
            document.getElementById('init-btn').click();
          });
        });
      } catch (err) {
        console.error('Error displaying x-cycle:', err);
        container.innerHTML = '';
      }
    }

    // Cycle animation state
    let cycleInterval = null;

    // Rotate p to next value (rotate right)
    function rotatePNext(p) {
      const binary = p.toString(2);
      const bitLength = binary.length;
      const stopBitPos = bitLength - 1;
      const stopBitMask = 1 << stopBitPos;
      const lowerBitsMask = stopBitMask - 1;

      const lowerBits = p & lowerBitsMask;
      const lsb = lowerBits & 1;
      const rotated = (lowerBits >> 1) | (lsb << (stopBitPos - 1));
      return rotated | stopBitMask;
    }

    // Rotate p to previous value (rotate left)
    function rotatePPrev(p) {
      const binary = p.toString(2);
      const bitLength = binary.length;
      const stopBitPos = bitLength - 1;
      const stopBitMask = 1 << stopBitPos;
      const lowerBitsMask = stopBitMask - 1;

      const lowerBits = p & lowerBitsMask;
      const msb = (lowerBits >> (stopBitPos - 1)) & 1;
      const rotated = ((lowerBits << 1) & lowerBitsMask) | msb;
      return rotated | stopBitMask;
    }

    // Load a new p value and update everything
    function loadP(newP) {
      const g = document.getElementById('input-g').value;
      const h = document.getElementById('input-h').value;

      document.getElementById('input-p').value = newP;
      updateBinaryDisplay();
      updateDerivedParameters();

      const url = new URL(window.location.href);
      url.searchParams.set('p', newP);
      url.searchParams.set('g', g);
      url.searchParams.set('h', h);
      // Preserve anchor if it exists, otherwise set it to the new p
      if (!url.searchParams.has('anchor')) {
        url.searchParams.set('anchor', newP);
      }
      window.history.pushState({}, '', url);

      document.getElementById('init-btn').click();
    }

    // Go to next p-value
    function goToNextP() {
      const p = parseP(document.getElementById('input-p').value);
      const nextP = rotatePNext(p);
      loadP(nextP);
    }

    // Go to previous p-value
    function goToPrevP() {
      const p = parseP(document.getElementById('input-p').value);
      const prevP = rotatePPrev(p);
      loadP(prevP);
    }

    // Toggle cycle animation
    function toggleCycle() {
      const cycleBtn = document.getElementById('cycle-btn');
      if (cycleInterval) {
        // Stop cycling
        clearInterval(cycleInterval);
        cycleInterval = null;
        cycleBtn.textContent = 'Cycle';
      } else {
        // Start cycling
        cycleInterval = setInterval(goToNextP, 1000);
        cycleBtn.textContent = 'Stop';
      }
    }

    // Stop cycle animation if running
    function stopCycle() {
      if (cycleInterval) {
        clearInterval(cycleInterval);
        cycleInterval = null;
        const cycleBtn = document.getElementById('cycle-btn');
        cycleBtn.textContent = 'Cycle';
      }
    }

    // Update derived parameters from p, g, h
    function updateDerivedParameters() {
      const p = parseP(document.getElementById('input-p').value);
      const g = parseInt(document.getElementById('input-g').value);
      const h = parseInt(document.getElementById('input-h').value);

      if (isNaN(p) || p <= 0 || isNaN(g) || g < 2 || isNaN(h) || h < 2) {
        return;
      }

      try {
        // Parse binary structure
        const structure = parseBinaryToStructure(p);
        const o = structure.o;
        const e = structure.e;

        // Compute k(g,h) - cofactor of q
        const k = computeK(structure.monomials, g, h);

        // Compute d(g,h) = h^e - g^o - cofactor of x‚ÇÄ
        const d = Math.pow(h, e) - Math.pow(g, o);

        // Compute gcd(k(g,h), d(g,h))
        const gcdValue = gcd(k, d);

        // Derive x‚ÇÄ and q from cycle element identity
        const x0 = Math.round(k / gcdValue);
        const q = Math.round(d / gcdValue);

        // Update display
        document.getElementById('output-o').textContent = o.toString();
        document.getElementById('output-e').textContent = e.toString();
        document.getElementById('output-q').textContent = q.toString();
        document.getElementById('output-x0').textContent = x0.toString();

        // Update x-cycle display
        displayXCycle();
      } catch (err) {
        console.error('Error deriving parameters:', err);
      }
    }

    // Listen for changes to p, g, h
    document.getElementById('input-p').addEventListener('input', () => {
      updateBinaryDisplay();
      updateDerivedParameters();
      updateURLParams();
    });

    document.getElementById('input-g').addEventListener('input', () => {
      updateDerivedParameters();
      updateURLParams();
    });

    document.getElementById('input-h').addEventListener('input', () => {
      updateDerivedParameters();
      updateURLParams();
    });

    // Stop cycle animation when input fields receive focus
    document.getElementById('input-p').addEventListener('focus', stopCycle);
    document.getElementById('input-g').addEventListener('focus', stopCycle);
    document.getElementById('input-h').addEventListener('focus', stopCycle);

    // Configuration
    document.getElementById('init-btn').addEventListener('click', () => {
      const g = parseInt(document.getElementById('input-g').value);
      const h = parseInt(document.getElementById('input-h').value);
      const o = parseInt(document.getElementById('output-o').textContent);
      const e = parseInt(document.getElementById('output-e').textContent);
      const q = parseInt(document.getElementById('output-q').textContent);
      const x0 = parseInt(document.getElementById('output-x0').textContent);

      try {
        app.initialize(o, e, g, h, q, x0);
        document.getElementById('validation-message').innerHTML =
          '<div class="success-message">‚úì Board initialized successfully!</div>';
        setTimeout(() => {
          document.getElementById('validation-message').innerHTML = '';
        }, 3000);

        // Display x-cycle after successful initialization
        displayXCycle();
      } catch (err) {
        document.getElementById('validation-message').innerHTML =
          `<div class="validation-error">‚úó ${err.message}</div>`;
      }
    });


    // Canvas interaction
    const canvas = document.getElementById('board-canvas');

    canvas.addEventListener('click', (e) => {
      if (!app.renderer) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const cell = app.renderer.pixelToGrid(x, y);
      if (cell) {
        app.selectedCell = cell;
        app.renderer.selectedCell = cell;
        app.render();
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!app.renderer) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const cell = app.renderer.pixelToGrid(x, y);
      app.renderer.hoveredCell = cell;
      app.render();
    });

    canvas.addEventListener('mouseleave', () => {
      if (!app.renderer) return;
      app.renderer.hoveredCell = null;
      app.render();
    });

    // Control buttons
    document.getElementById('undo-btn').addEventListener('click', () => app.undo());
    document.getElementById('redo-btn').addEventListener('click', () => app.redo());
    document.getElementById('reset-btn').addEventListener('click', () => app.reset());
    document.getElementById('animate-btn').addEventListener('click', () => app.startAnimation());

    // Pop-out buttons
    document.getElementById('popout-stats-btn').addEventListener('click', () => app.popoutStatsGraph());
    document.getElementById('popout-entropy-btn').addEventListener('click', () => app.popoutEntropyGraph());

    // Conservation law buttons
    document.getElementById('g-right-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));

      app.showInputModal(
        '√óg Right ‚Üí',
        `Move how many pebbles to the right? (creates ${app.board.g} pebbles per pebble moved)`,
        count,
        (num) => {
          const success = app.applyAction({type: 'gRight', j, i, count: num});
          if (success) {
            app.selectedCell = { j: j + 1, i: i };
            app.renderer.selectedCell = app.selectedCell;
            app.render();
          }
        }
      );
    });

    document.getElementById('g-left-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));
      const maxSets = Math.floor(count / app.board.g);

      const spreadMode = document.getElementById('spread-mode').checked;

      if (spreadMode && maxSets > 0) {
        // In spread mode, automatically use max without prompting
        const success = app.applyAction({type: 'gLeft', j: j - 1, i, count: maxSets});
        if (success) {
          app.selectedCell = { j: j - 1, i: i };
          app.renderer.selectedCell = app.selectedCell;
          app.render();

          // Repeat if possible
          setTimeout(() => {
            const newCount = Math.abs(app.board.get(j - 1, i));
            const newMaxSets = Math.floor(newCount / app.board.g);
            if (newMaxSets > 0) {
              document.getElementById('g-left-btn').click();
            }
          }, 100);
        }
      } else {
        // Normal mode - show prompt
        app.showInputModal(
          '‚Üê √óg Left',
          `Combine how many sets of ${app.board.g} pebbles into 1? (max: ${maxSets})`,
          maxSets,
          (num) => {
            const success = app.applyAction({type: 'gLeft', j: j - 1, i, count: num});
            if (success) {
              app.selectedCell = { j: j - 1, i: i };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          },
          maxSets
        );
      }
    });

    document.getElementById('h-down-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));

      app.showInputModal(
        '√óh Down ‚Üì',
        `Move how many pebbles down? (creates ${app.board.h} pebbles in square below)`,
        count,
        (num) => {
          const success = app.applyAction({type: 'hDown', j, i, count: num});
          if (success) {
            app.selectedCell = { j: j, i: i - 1 };
            app.renderer.selectedCell = app.selectedCell;
            app.render();
          }
        }
      );
    });

    document.getElementById('h-up-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));
      const maxSets = Math.floor(count / app.board.h);

      const spreadMode = document.getElementById('spread-mode').checked;

      if (spreadMode && maxSets > 0) {
        // In spread mode, automatically use max without prompting
        const success = app.applyAction({type: 'hUp', j, i, count: maxSets});
        if (success) {
          app.selectedCell = { j: j, i: i + 1 };
          app.renderer.selectedCell = app.selectedCell;
          app.render();

          // Repeat if possible
          setTimeout(() => {
            const newCount = Math.abs(app.board.get(j, i + 1));
            const newMaxSets = Math.floor(newCount / app.board.h);
            if (newMaxSets > 0) {
              document.getElementById('h-up-btn').click();
            }
          }, 100);
        }
      } else {
        // Normal mode - show prompt
        app.showInputModal(
          '‚Üë √óh Up',
          `Combine how many sets of ${app.board.h} pebbles into square above? (max: ${maxSets})`,
          maxSets,
          (num) => {
            const success = app.applyAction({type: 'hUp', j, i, count: num});
            if (success) {
              app.selectedCell = { j: j, i: i + 1 };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          },
          maxSets
        );
      }
    });

    document.getElementById('special-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));
      const specialType = app.laws.getSpecialSystemType();
      const basisFormula = app.laws.getBasisLawDescription();

      const gPlus1 = app.board.g + 1;
      const digits = app.laws.toBaseH(gPlus1, app.board.h);
      const maxPower = digits.length - 1;

      app.showInputModal(
        `Basis Law (${specialType})`,
        `Apply ${basisFormula}: Replaces pebble at (j=${j},i=${i}) with base-${app.board.h} expansion of (g+1) at column j+1, minus 1. How many pebbles?`,
        count,
        (num) => {
          const success = app.applyAction({type: 'basisLaw', j, i, count: num});
          if (success) {
            app.selectedCell = { j: j + 1, i: i + maxPower };
            app.renderer.selectedCell = app.selectedCell;
            app.render();
          }
        }
      );
    });

    document.getElementById('reverse-special-btn').addEventListener('click', () => {
      if (!app.selectedCell) return;
      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));
      const specialType = app.laws.getSpecialSystemType();
      const basisFormula = app.laws.getBasisLawDescription();

      const gPlus1 = app.board.g + 1;
      const digits = app.laws.toBaseH(gPlus1, app.board.h);
      const maxPower = digits.length - 1;

      app.showInputModal(
        `Reverse Basis Law (${specialType})`,
        `Apply inverse of ${basisFormula}: Uses h^${maxPower} = (g+1) - (lower powers). Splits pebble from (j=${j},i=${i}) into column j-1 at i-${maxPower}. How many pebbles?`,
        count,
        (num) => {
          const success = app.applyAction({type: 'reverseBasisLaw', j, i, count: num});
          if (success) {
            app.selectedCell = { j: j - 1, i: i - maxPower };
            app.renderer.selectedCell = app.selectedCell;
            app.render();
          }
        }
      );
    });

    document.getElementById('reset-k-btn').addEventListener('click', () => {
      app.resetK();
    });

    document.getElementById('random-btn').addEventListener('click', () => {
      app.startRandomExecution();
    });

    document.getElementById('local-minimiser-btn').addEventListener('click', () => {
      app.startLocalMinimiserExecution();
    });

    // Persistence buttons
    document.getElementById('copy-url-btn').addEventListener('click', () => persistence.copyURL());
    document.getElementById('save-local-btn').addEventListener('click', () => persistence.saveToLocalStorage());
    document.getElementById('load-local-btn').addEventListener('click', () => persistence.loadFromLocalStorage());
    document.getElementById('export-json-btn').addEventListener('click', () => persistence.exportJSON());
    document.getElementById('import-json-btn').addEventListener('click', () => {
      document.getElementById('json-file-input').click();
    });

    document.getElementById('json-file-input').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        persistence.importJSON(file).then(() => {
          alert('‚úì Configuration imported successfully!');
        }).catch(err => {
          alert(`‚úó Failed to import: ${err.message}`);
        });
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Don't trigger shortcuts when typing in input fields
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
      }

      // Undo/Redo
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z' && !e.shiftKey) {
          e.preventDefault();
          app.undo();
        } else if (e.key === 'z' && e.shiftKey || e.key === 'y') {
          e.preventDefault();
          app.redo();
        }
        return;
      }

      // Global shortcuts (don't require selected cell)
      switch(e.key.toLowerCase()) {
        case 'v': // Reset q¬∑k (clear board to x‚ÇÄ¬∑d part)
          e.preventDefault();
          app.resetK();
          return;

        case 'm': // Local Minimiser
          e.preventDefault();
          app.startLocalMinimiserExecution();
          return;
      }

      // Conservation law shortcuts (l, r, u, d, f, b)
      if (!app.selectedCell) return;

      const { j, i } = app.selectedCell;
      const count = Math.abs(app.board.get(j, i));
      const numPebbles = e.shiftKey ? count : 1; // Shift = max, no shift = 1

      switch(e.key.toLowerCase()) {
        case 'l': // Left
          e.preventDefault();
          const maxLeft = Math.floor(count / app.board.g);
          if (maxLeft > 0) {
            const numLeft = e.shiftKey ? maxLeft : 1;
            const success = app.applyAction({type: 'gLeft', j: j - 1, i, count: numLeft});
            if (success) {
              app.selectedCell = { j: j - 1, i: i };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'r': // Right
          e.preventDefault();
          if (count > 0) {
            const success = app.applyAction({type: 'gRight', j, i, count: numPebbles});
            if (success) {
              app.selectedCell = { j: j + 1, i: i };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'u': // Up
          e.preventDefault();
          const maxUp = Math.floor(count / app.board.h);
          if (maxUp > 0) {
            const numUp = e.shiftKey ? maxUp : 1;
            const success = app.applyAction({type: 'hUp', j, i, count: numUp});
            if (success) {
              app.selectedCell = { j: j, i: i + 1 };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'd': // Down
          e.preventDefault();
          if (count > 0) {
            const success = app.applyAction({type: 'hDown', j, i, count: numPebbles});
            if (success) {
              app.selectedCell = { j: j, i: i - 1 };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'f': // Forward (Basis Law)
          e.preventDefault();
          if (count > 0 && app.laws.canApplySpecial(j, i)) {
            const gPlus1 = app.board.g + 1;
            const digits = app.laws.toBaseH(gPlus1, app.board.h);
            const maxPower = digits.length - 1;
            const success = app.applyAction({type: 'basisLaw', j, i, count: numPebbles});
            if (success) {
              app.selectedCell = { j: j + 1, i: i + maxPower };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'b': // Backward (Reverse Basis Law)
          e.preventDefault();
          if (count > 0 && app.laws.canApplyReverseSpecial(j, i)) {
            const gPlus1 = app.board.g + 1;
            const digits = app.laws.toBaseH(gPlus1, app.board.h);
            const maxPower = digits.length - 1;
            const success = app.applyAction({type: 'reverseBasisLaw', j, i, count: numPebbles});
            if (success) {
              app.selectedCell = { j: j - 1, i: i - maxPower };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;

        case 'q': // Leave q pebbles (cycle parameter), move rest right
          e.preventDefault();
          const q = app.board.q;
          if (count > q && q >= 1) {
            const toMove = count - q;
            const success = app.applyAction({type: 'gRight', j, i, count: toMove});
            if (success) {
              app.selectedCell = { j: j + 1, i: i };
              app.renderer.selectedCell = app.selectedCell;
              app.render();
            }
          }
          break;
      }
    });

    // Load from URL or initialize default
    window.addEventListener('load', () => {
      // Check for query parameters p, g, h
      const urlParams = new URLSearchParams(window.location.search);
      const pParam = urlParams.get('p');
      const gParam = urlParams.get('g');
      const hParam = urlParams.get('h');

      // Set input fields from query parameters if present
      let hasQueryParams = false;
      if (pParam !== null) {
        document.getElementById('input-p').value = pParam;
        hasQueryParams = true;
      }
      if (gParam !== null) {
        document.getElementById('input-g').value = gParam;
        hasQueryParams = true;
      }
      if (hParam !== null) {
        document.getElementById('input-h').value = hParam;
        hasQueryParams = true;
      }

      // Initialize derived parameters with default or query param values
      updateBinaryDisplay();
      updateDerivedParameters();

      // Check for state parameter (takes precedence over query params)
      if (!persistence.loadFromURL()) {
        // Initialize board with current values (query params or defaults)
        document.getElementById('init-btn').click();
      }

      // Scroll to board after initialization
      setTimeout(() => {
        const boardContainer = document.getElementById('board-container');
        if (boardContainer) {
          boardContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }, 100);

      // Add event listeners for cycle navigation buttons
      document.getElementById('prev-btn').addEventListener('click', goToPrevP);
      document.getElementById('next-btn').addEventListener('click', goToNextP);
      document.getElementById('cycle-btn').addEventListener('click', toggleCycle);
    });
  </script>
</body>
</html>
